死锁：多个进程都被阻塞，并且一直处于这种状态。软硬件资源都有可能。

死锁规范定义在 6.2

本章讨论几类死锁，如何出现，如何防止或避免死锁的方法。



## 6.1 资源

为了更好的讨论将，需要排他性使用的对象称为『资源』。



### 6.1.1 可抢占资源和不可抢占资源

可抢占资源：可以从拥有它的进程中抢占，如内存（可以页面置换）

不可抢占资源：不引起相关计算失败的情况下，无法将它从其他占有它的进程处抢占过来。如打印机



死锁与不可抢占资源有关，可抢占资源有潜在死锁可以通过分配资源化解，所以重点讨论不可抢占资源。

使用一个资源的事件顺序可以抽象如下：

+ 请求资源
+ 使用资源
+ 释放资源



在后面讨论中假设：如果某个进程请求资源失败，那么它就进入休眠状态。



### 6.1.2 资源获取

这段讲了例子，不好总结，信号量表示资源状态，down 操作获取资源，up 操作释放资源。



## 6.2 死锁简介

死锁规范定义如下：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发事件，那么，该进程集合就是死锁的。



资源死锁：进程互相等待其他进程释放资源，无法被释放照成的死锁



### 6.2.1 资源死锁的条件

+ 互斥条件。每个资源要么已经被分配给一个进程，要么可用
+ 占有和等待条件。已经得到了某个资源的进程可以再请求新的资源。
+ 不可抢占条件。已经被分配给一个进程的资源不能强制性地被抢占。
+ 环路等待条件。一定有至少两个进程组成一条环路，环路中每个进程等待下个进程所占有的资源



### 6.2.2 死锁建模

用有向图简历上述模型。

两类节点：圆形表示进程，方形表示资源。

从资源节点到进程节点的有向边代表该资源已被请求、授权并被进程占用。

由进程节点到资源节点的有向边代表该进程正在请求该资源，并且已经被阻塞。



资源分配图，可以用来作分析工具，检查是否有环即可判断是否存在死锁。



## 6.3 鸵鸟算法

最简单的方法是没有方法，放弃预防死锁发生。根据频率、严重性等考量。



## 6.4 死锁检测和死锁恢复

允许死锁发生。



### 6.4.1 每种类型一个资源的死锁检测

每种资源类型只有一个资源。



介绍了一个检测资源分配图是否存在环的算法。



### 6.4.2 每种类型多个资源的死锁检测



这块没看懂

好像是说银行家算法，找到可运行的，运行，释放，最后剩的就是死锁。

但是这样好像不能多个进程同时运行，同时运行的话进程之间执行指令不确定，判死锁有点问题，感觉少了。

网上看个银行家算法就略过这



什么时候检测进程？

每次资源请求时，代价高

每隔一段时间或 CPU 使用率低时。没讲缺点，但应该感觉不及时也不太行。



### 6.4.3 从死锁中恢复

#### 1. 利用抢占恢复

需要资源本身特性的支持。



#### 2. 利用回滚恢复

检查点检查：将进程的状态写入一个文件以备以后重启

检测到死锁，将拥有所需要资源的进程进行回滚。



#### 3. 通过直接杀死进程

直接杀死某些进程，解决死锁。最好杀死重新执行后不会影响结果的进程。



## 6.5 死锁避免

### 6.5.1 资源轨迹图

### 6.5.2 安全状态和不安全状态

安全状态：存在某种调度次序能够使每个进程都运行完毕

不安全状态不代表死锁，从安全状态出发能保证所有进程完成，而不安全状态不能保证。



### 6.5.3 单个银行家算法

银行家算法：避免死锁的调度算法

对每一个请求进行检查，如果满足这一请求会到达安全状态就满足，否则推迟请求。



### 6.5.4 多个资源的银行家算法

思想和单个银行家算法一样，只不过资源变多。



该算法缺乏实用价值。因为很少有进程能够运行前就知道其所需资源最大值。而且进程数不是固定不变的。而且原本可用资源可能也会变成不可用。



## 6.6 死锁预防

死锁避免从本质上来说不可能。



### 6.6.1 破坏互斥条件

比如打印机被多个进程同时使用会混乱。通过假脱机打印机技术，可以使若干进程同时产生输出，真正请求物理打印机的进程是打印机守护进程，由于守护进程绝不请求别的资源，所以不会因打印机产生死锁。



### 6.6.2 破坏占有并等待条件

规定所有进程在开始执行前请求所需的全部资源，如果所需全部资源可用，那么就将它们分配给这个进程。

缺点多，如果知道需要哪些进程可以银行家算法；资源利用率不高，可能某个资源等待另个资源，但同时被申请了。



另种方案，当一个进程请求资源，先暂停释放当前占用的所有资源，再尝试一次获取所有所需资源。



### 6.6.3 破坏不可抢占条件

通过资源虚拟化，但是不是所有资源都可以虚拟化。



### 6.6.4 破坏环路等待条件

一种方案，保证每个进程任何时刻只能占用一个资源，这个限制不可接受。

另一种方案，将所有资源统一编号，进程提出资源请求需要满足资源编号顺序（如升序）提出。差不多就定义一个拓扑序，所以无环。

另一变种，第二种的请求限制改为，不允许进程请求比当前所占有资源编号低的资源。还是无环图

这两种方案找不出使每个人都满意的编号次序，编号越大限制越多。



## 6.7 其他问题

### 6.7.1 两阶段加锁

第一阶段对所需资源请求加锁，加锁成功执行第二阶段，然后释放锁；加锁失败，释放第一阶段加锁记录，然后重新加锁。

该方法并不通用。



### 6.7.2 通信死锁

通信死锁：没有完全可见的资源，每个进程因为等待另外一个进程事件而产生的死锁。

有一种技术通常可以中断通信死锁：超时

都快到计网TCP了。。



### 6.7.3 活锁

进程同时请求发现无法使用，继续一段时间，然后同时释放。

一种解决方法，可以使等待时间随机，这样就不会同步了。



### 6.7.4 饥饿

某个进程一直（很久）无法占用资源，比较常见于优先级调度中。感觉可以整个老化算法解决。



## 6.8 有关死锁的研究

## 6.9 小结