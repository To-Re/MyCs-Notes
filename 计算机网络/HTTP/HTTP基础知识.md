超文本传输协议，属于应用层。基于 TCP，是无连接、无状态的协议。

HTTP 客户端是一个应用程序，可以是 WEB 浏览器或其他任何客户端。

HTTP 服务端也是一个应用程序，通常是一个 WEB 服务，如 Apache web 服务器。

HTTP 使用统一资源定位器（URI）来传输数据和建立连接。URL 是 URI 的一种。



### HTTP 请求方法

+ GET：一般是获取资源
+ POST：传输实体主体，主要用于将信息告诉服务器
+ HEAD：获取报文首部



### HTTP 连接类型

HTTP 1.0 版本使用非持久性连接，每个 TCP 连接最多允许传输一个对象。

HTTP 1.1 版本默认使用持久性连接，每个 TCP 连接允许传输多个对象。



### HTTP 状态码

| 状态码 | 类别             | 原因短语                   |
| ------ | ---------------- | -------------------------- |
| 1xx    | 信息性状态码     | 接收的请求正在处理         |
| 2xx    | 成功状态码       | 请求正常处理完毕           |
| 3xx    | 重定向状态码     | 需要进行附加操作以完成请求 |
| 4xx    | 客户端错误状态码 | 服务器无法处理请求         |
| 5xx    | 服务器错误状态码 | 服务器处理请求出错         |



200 OK：正常处理

204 NO Content：处理成功，但响应中没有任何实体

301 Moved Permanently：永久性重定向，该资源已经分配了新的 URI，原来的 URI 不再使用

304 Not Modified：条件性 get，版本一致无需改变

400 Bad Request：请求报文中存在语法错误

403 Forbidden：不允许访问这个资源

404 Not Found：服务器无法找到请求的资源



### Cookie

Q：为什么要 Cookie

A：HTTP 协议是无状态的，存在需要服务器掌握客户端的状态的情况。



Cookie 组件

+ HTTP 响应消息的 Cookie 头部行
+ HTTP 请求消息的 Cookie 头部行
+ 保存在客户端主机上的 Cookie 文件，由浏览器管理
+ Web 服务器端的后台数据库



### Web 缓存/代理服务器技术

不访问服务器的前提下满足客户端的 HTTP 请求。



作用

+ 缩短客户端请求的响应时间
+ 减少服务器流量



原理

+ 用户设定浏览器通过缓存进行 Web 访问
+ 浏览器向缓存/代理服务器发送所有的 HTTP 请求
  + 如果所请求对象在缓存中，缓存返回对象
  + 否则，缓存服务器向原始服务器发送 HTTP 请求，获取对象。然后返回给客户端并保存该对象。



#### 条件性 GET 方法

目标：解决缓存版本与最新版本不一致问题。如果缓存有最新版本，则不需要发送请求对象

原理

+ 缓存服务器向服务器发送条件性 get 方法
  + 没改变，返回 304 Not Modified
  + 改变，返回 200 ok，并且返回最新版本



### HTTPS

http 协议有几点不足

+ 明文通信，内容可能会被窃听
+ 不验证通信方的身份，因此可能遭遇伪装
+ 无法验证报文的完整性，所以有可能篡改



HTTPS = HTTP + 加密 + 认证 + 完整性保护，可以理解为 HTTPS 是 HTTP 通信接口部分用 SSL 协议通信。


对称加密：加密解密使用同一个密钥

非对称加密：公钥加密，私钥解密。相较非对称加密对称加密更加高效。

数字证书：主要包含发布机构，有效期，公钥，证书所有者，签名使用的算法，指纹及指纹算法，签名哈希算法。数字证书用来保证公钥一定是证书持有者的。

数字签名：用 Hash 加密生成摘要，再将摘要使用密钥加密。验证只需比较原文哈希值和公钥解密数字签名。



HTTPS 通信大致流程

+ 客户端发起 https 请求，连接到服务器的 443 端口。
+ 服务器将自己的信息以数字证书形式返回给客户端
+ 客户端验证证书的合法性：通过证书上的签发机构，在浏览器内置的根证书里找到对应公钥，用公钥进行数字签名验证
+ 验证证书合法性后从证书中取出服务器的公钥，浏览器生成对称密钥，通过服务器公钥加密发送给服务器
+ 服务器使用私钥解密，得到对称密钥
+ 之后客户端和服务器通过对称密钥进行通信

