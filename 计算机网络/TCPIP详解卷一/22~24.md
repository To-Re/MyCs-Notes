# 第22章 TCP的坚持定时器

# 22.1 引言

TCP 连接可能存在，接收方等待修改窗口大小的 ACK，但是此 ACK 丢失产生死锁的情况。因为 TCP 不对空的 ACK 进行确认。

所以需要使用『坚持定时器』周期性向接收方查询，发现窗口是否变大。这些从发送方发出的报文段称为窗口探查。

本章讨论，窗口探查、坚持定时器、糊涂窗口综合症。



## 22.2 一个例子

在收到一个大小为 0 的窗口通告后，坚持定时器开始启动，定时器到时间就发送『窗口探测』。

间隔时间这个例子中是，5，5，6，12，24，48，60，60，60，单位是秒。

这个坚持定时器直到窗口打开或者连接终止才会停止。



## 22.3 糊涂窗口综合症

糊涂窗口综合症：发送端应用进程产生数据很慢、或接收端应用进程处理接收缓冲区数据很慢，会使应用进程间传送的报文段很小。

极端情况下，有效载荷可能只有 1 个字节，传输开销有 40 字节。



措施：

+ 接收方不通告小窗口，等到窗口变大（窗口可以增加一个报文段大小或者可以增加接收方缓存空间的一半）在通告
+ 发送方措施，满足以下条件之一才发送
  + 可以发送一个满长度的报文段
  + 可以发送至少是接收方通告窗口大小一半的报文段
  + 第三种没看懂，可以发送任何数据并且不希望接收 ACK（也就是说，没有还未被确认的数据）或者该连接上不能使用 Nagle 算法



## 22.4 小结

介绍坚持定时器、糊涂窗口综合症避免方法。



# 第23章 TCP的保活定时器

## 23.1 引言

保活定时器：某一方希望查看另一方是否仍然还在

保活不是 TCP 规范中的一部分，但许多实现提供了保活定时器



## 23.2 描述

接下来假设服务器开启保活选项，客户没有。

连接在一段时间（默认值不小于 2 小时）之内没有任何动作，则服务器向客户发送一个探查报文段

客户主机必须处于以下 4 个状态之一

+ 客户主机依然正常运行，并且消息可达。重置保活定时器。
+ 客户主机已经崩溃，并且关闭或者正在重新启动。消息超时没有响应，TCP 多次探查失败则关闭连接。
+ 客户主机崩溃并已经重新启动。返回一个复位响应。
+ 客户主机正常运行，但是消息不可达。和第二种状态相同。



## 23.3 保活举例

### 23.3.1 另一端崩溃

### 23.3.2 另一端崩溃并重新启动

### 23.3.3 另一端不可达

## 23.4 小结

讲了个保活定时器，和例子。



# 第24章 TCP的未来和性能

## 24.1 引言

路径 MTU 发现机制，可以使 TCP 为非本地的连接使用大于 536 字节的 MTU，从而增加吞吐量

长肥管道：很大的带宽时延乘积的网络

TCP 选项：

+ 窗口扩大选项，增加 TCP 窗口
+ 时间戳选项，进行更加精确的 RTT 测量，还对序号回绕提供保护



## 24.2 路径MTU发现

### 24.2.1 一个例子

### 24.2.2 大分组还是小分组

## 24.3 长肥管道

长肥管道：很大的带宽时延乘积的网络

长肥管道的问题：

+ 需要更大的窗口增加吞吐量
+ 分组丢失会使吞吐量急剧减少。多分组丢失容易使管道耗尽
+ 需要更好的 RTT 测量机制
+ 延迟的报文，在重新建立的连接中如何避免出现



千兆比网络中，传输时间，时延占据主要，带宽不再成为限制



## 24.4 窗口扩大选项

定义一个扩大选项，额外增加 16 bit，移位值最大 14，使得窗口大小最大能够到达 $2^{30}$ bit。

这个选项只能出现在一个 SYN 报文段中，所以连接建立后每个方向的扩大因子是固定的。



主动建立连接的一方在其 SYN 中发送这个选项，被动建立连接的一方只能够在收到带有这个选项的 SYN 之后才可以发送这个选项。每个方向上的扩大因子可以不同。

如果主动连接的一方发送一个非零的扩大因子，但是没有从另一端收到一个窗口扩大选项，它就将发送和接收的移位记数器置为 0，兼容旧版本。



选项用法如下

> 发送移位记数为 S，而接收移位记数则为 R。
>
> 从另一端收到的每一个 16 bit 的通告窗口将被左移 R 位以获得实际的通告窗口大小。
>
> 发送一个窗口通告的时候，我们将实际的 32 bit 窗口大小右移 S 位，然后用它来替换 TCP 首部中的 16 bit 的值。



下面举了一个例子



## 24.5 时间戳选项

时间戳选项：发送方设置时间戳值，接收方在确认中返回这个数值。

更好的计算 RTT



收到多个报文段的时间戳，返回一个 ACK 如何返回？

为了减少任一端所维持的状态数量，对于每个连接只保持一个时间戳的数值。

+ TCP 跟踪下一个 ACK 中将要发送的时间戳的值（tsrecent 变量）以及最后发送的 ACK 中的确认序号（lastack 变量）。这个序号就是接收方期望的序号。
+ 当一个包含有字节号 lastack 的报文段到达时，则该报文段中的时间戳被保存在 tsrecent 中。

+ 无论何时发送一个时间戳选项，tsrecent 就作为时间戳回显应答字段被发送，而序号字段被保存在 lastack 中。



如果 ACK 被时延，则作为回显值的时间戳值应该对应于最早被确认的报文段。因为发送方在进行重传超时时间的计算时， 必须将迟延的 ACK 也考虑在内。如发送两个报文段1，2。返回 ACK 3，应该计算 1 的时间戳。

如果一个收到的报文段虽然在窗口范围内但同时又是失序，这就表明前面的报文段已经丢失。当那个丢失的报文段到达时，它的时间戳（而不是失序的报文段的时间戳）将被回显。



下节介绍避免收到旧的报文段，并认为是现在的数据中的一部分。



## 24.6 PAWS：防止回绕的序号

PAWS 算法不需要在发送方和接收方之间进行任何形式的时间同步。接收方所需要的就是时间戳的值应该单调递增，并且每个窗口至少增加 1。

通过判断时间戳确认有没有序号回绕。



## 24.7 T/TCP：为事务用的TCP扩展

TCP 为处理事务而需要进行的两个改动是避免三次握手和缩短 WAIT_TIME 状态。

T/TCP 通过使用加速打开来避免三次握手：

+ 它为打开的连接指定一个 32 bit 的连接计数 CC，无论主动打开还是被动打开。一个主机的 CC 值从一个全局计数器中获得，该计数器每次被使用时加 1。
+ 在两个使用 T/TCP 的主机之间的每一个报文段都包括一个新的 TCP 选项 CC。这个选项的长度为 6 个字节，包含发送方在该连接上的 32 bit 的 CC 值。
+ 一个主机维持一个缓存，该缓存保留每个主机上一次的 CC 值，这些值从来自这个主机的一个可接受的 SYN 报文段中获得。
+ 当在一个开始的 SYN 中收到一个 CC 选项的时候，接收方比较收到的值与缓存的发送方的 CC 值。
  + 如果接收到的 CC 比缓存的大，则该 SYN 是新的，报文段中的任何数据被传递给接收应用进程（服务器）。这个连接被称为半同步。
  + 如果接收的 CC 比缓存的小，或者接收主机上没有对应这个客户的缓存 CC，则执行正常的 TCP 三次握手过程。
+ 为响应一个开始的 SYN，带有 SYN 和 ACK 的报文段在另一个被称为 CCECHO 的选项中回显所接收到的 CC 值。
+ 在一个非 SYN 报文段中的 CC 值检测和拒绝来自同一个连接的前一个替身的任何重复的报文段。

这种『加速打开』避免了使用三次握手的要求，除非客户或者服务器已经崩溃并重新启动。这样做的代价是服务器必须记住从每个客户接收的最近的 CC 值。



uysy 有些地方没看懂，特别是第六点：

> 在一个非 SYN 报文段中的 CC 值检测和拒绝来自同一个连接的前一个替身的任何重复的报文段。
>
> 这个『和』啥玩意连接了什么？

大概就是一次握手，顺便直接发送数据了。

这块内容我选择跳过，到时面经看到再说。



## 24.8 TCP的性能

## 24.9 小结



大概知道了，坚持定时器、糊涂窗口综合症、保活定时器、窗口扩大选项、时间戳选项。

其他节不太清楚只是了解一二。