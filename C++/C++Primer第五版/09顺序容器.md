# 9 顺序容器

顺序容器：为程序员提供了控制元素存储和访问顺序的能力。



## 9.1 顺序容器概述

#### 顺序容器类型

| 类型                  | 功能                                                 |
| --------------------- | ---------------------------------------------------- |
| vector                | 可变大小数组。支持快速随机访问。                     |
| deque                 | 双端队列。支持快速随机访问。                         |
| list                  | 双向链表。支持双向顺序访问。                         |
| forward_list（C++11） | 单向链表。支持单向顺序访问。                         |
| array（C++11）        | 固定大小数组。支持快速随机访问。                     |
| string                | 与 vector 类似容器，专门保存字符。支持快速随机访问。 |

#### 确定使用哪种顺序容器

以下是基本原则：

+ 除非有更好理由选择其他容器，否则使用 vector
+ 程序有很多小元素，且空间的额外开销很重要，不要使用 list 或 forward_list
+ 如果程序要求随机访问元素，应使用 vector 或 deque
+ 程序要求在容器中间插入或删除元素，应使用 list 或 forward_list
+ 程序要求在头尾插入删除元素，不会中间插入删除，使用 deque
+ 只有输入时容器中间插入元素，后续随机访问，可以先 list 输入，而后 list 中内容拷贝到 vector。
+ 又要中间插入，又要随机访问，自行测试不同容器的性能。



## 9.2 容器库概览

本节介绍所有容器都适用的操作。本章剩余部分将介绍仅适用于顺序容器的操作。



容器操作表，太长见原书 P295



### 9.2.1 迭代器

迭代器范围：begin 和 end。begin 开始，end 前结束。

迭代器遍历容器

```cpp
while (begin != end) {
    ++begin;
}
```



### 9.2.2 容器类型成员

size_type：3.2.2 节

iterator 和 const_iterator：3.4.1 节

反向迭代器：10.4.3 节介绍

类型别名：16 章介绍

为了使用容器内类型别名需要作用域运算符。如 `vector<int>::difference_type count;`



### 9.2.3 begin 和 end 成员

`begin()` ：重载过，如果容器是常量，返回常量，否则返回非常量

`rbegin()` ：返回反向迭代器

`cbegin()` ：返回常量迭代器

`crbegin()` ：返回常量反向迭代器

end有如上类似操作。

`auto it = a.begin();` 当 a 是 const 时，it 是常量迭代器。



### 9.2.4 容器定义和初始化

除 array 之外，其他容器的默认构造函数都会创建一个指定类型的空容器。

容器定义和初始化

| 操作        | 功能                                                         |
| ----------- | ------------------------------------------------------------ |
| C c;        | 默认构造                                                     |
| C c1(c2);   | c1 初始化为 c2 的拷贝                                        |
| C c{a,b,c}; | 初始化为初始化列表元素的拷贝                                 |
| C c(b,e);   | c 初始化为迭代器 b 和 e 指定范围中的元素的拷贝（array 不适用）左闭右开区间 |
| C seq(n);   | seq 包含 n 个元素                                            |
| C seq(n,t); | seq 包含 n 个初始化为值 t 的元素                             |

#### 容器拷贝

将一个新容器创建为另一个容器的拷贝方法有两种：

+ `C c1(c2);` ：两个容器的类型及元素类型需要匹配
+ `C c(b, e);` ：迭代器范围拷贝，不需要容器类型相同，只需要原容器内元素能转换为新容器内元素



#### 列表初始化

初始化列表显示指定容器内每个元素的值。且除 array 之外的容器类型，还隐含地指定了容器的大小。



#### 与顺序容器大小相关的构造函数

下面构造方法，关联容器和 `array` 不可用。

`C seq(n);`

`C seq(n,t);`



#### 标准库 array 具有固定大小

定义 array

需要指定元素类型及容器大小，如 `array<int, 42>` 。如果有参数列表，参数列表长度需要小于等于 array 的大小。

拷贝 array

```cpp
array<int, 2> digits = {0,1};
array<int, 2> copy = digits;
```



### 9.2.5 赋值和 swap

容器赋值运算

| 运算方法                   | 功能                                                         |
| -------------------------- | ------------------------------------------------------------ |
| c1 = c2                    | 将 c1 中的元素替换为 c2 中元素的拷贝。c1 和 c2 必须具有相同的类型。 |
| c = {a,b,c...}             | 将 c1 中的元素替换为初始化列表中元素的拷贝（array 不适用）   |
| swap(c1,c2) 和 c1.swap(c2) | 交换 c1 和 c2 中的元素。c1 和 c2 必须具有相同的类型。swap 通常比 c2 向 c1 拷贝快 |
|                            | assign 操作不适用于『关联容器』和『array』                   |
| seq.assign(b,e)            | 将 seq 中的元素替换为迭代器 b 和 e 范围内的元素。b 和 e 不能是指向 seq 中的元素。 |
| seq.assign(il)             | 将 seq 中的元素替换为初始化列表 il 中的元素                  |
| seq.assign(n,t)            | seq 中的元素替换为 n 个值为 t 的元素                         |

#### 使用 assign

允许拷贝替换不同类型的容器

```cpp
list<string> names;
vector<const char*> oldstyle;
name = oldstyle; // 错误：容器类型不匹配
name.assign(oldstyle.cbegin(), oldstyle.cend()); // 正确拷贝
```



#### 使用 swap

swap，不会导致指向容器的迭代器、引用和指针失效。（除 string）

swap 两个 array 会真正交换它们的元素。因此，交换两个 array 时间与元素数目成正比。

与 vector 不同，array 中，swap 后，迭代器、指针、引用绑定的元素不会变。（即绑定的会变成替换后的值）



### 9.2.6 容器大小操作

size：返回容器中元素的数目

empty：当容器 suze 为 0 时，返回 true，否则返回 false。

max_size：返回一个大于等于该类型容器所能容纳的最大元素数的值。

forward_list 不支持 size。



### 9.2.7 关系运算符

每个容器类型都支持相等运算符（== 和 !=）

除了无序关联容器外的所有容器支持（>、>=、<、<=）

容器的关系运算符使用元素的关系运算符完成比较。



## 9.3 顺序容器操作

待

