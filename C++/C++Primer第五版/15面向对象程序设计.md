# 15 面向对象程序设计

## 15.1 OOP：概述

OOP：面向对象程序设计。核心思想是数据抽象、继承、动态绑定。

数据抽象，可以将类的接口与实现分离。

继承，可以定义相似的类型并对其相似关系建模。

动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。



#### 继承

+ 继承：将类构成一种层次关系。
+ 基类：通常在层次关系的根部。负责定义层次关系中所有类共有对象。
+ 派生类：直接或间接地从基类继承而来。负责定义每个类各自特有的对象。

派生类必须通过类派生列表指出它从哪些基类继承而来。

类派生列表的形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符。

`class Bulk_quote : public Quote {}` Bulk_quote 继承了 Quote



+ 虚函数：基类希望它的派生类各自定义适合自身的版本，此时基类将这些函数声明为虚函数。

`virtual double net_price(std::size_t n) const;` 基类中一个虚函数的声明。

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样函数前加上 `virtual` 关键字，但不是必要的。（15.3 节解释原因）

C++11 新标准允许派生类显式地注明使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后加上 `override` 关键字。



#### 动态绑定

通过动态绑定能使用同一代码分别处理两个对象。当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。



## 15.2 定义基类和派生类

### 15.2.1 定义基类

基类通常都应该定义一个虚析构函数（15.7.1 节介绍），即使该函数不执行任何实际操作。

虚函数只能出现在类内部的声明语句之前。

派生类能访问基类公有成员，不能访问私有成员。并且定义一种保护成员 `protected` 派生类有权访问，其他用户禁止访问。



### 15.2.2 定义派生类

派生类必须通过『派生类列表』明确指出从哪个基类继承而来。

类派生列表的形式是：首先一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符 `public` 、 `protected` 、 `private` 。

`class Bulk_quote : public Quote {}`

访问说明符作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。（15.5 节详细介绍）





#### 派生类中的虚函数

派生类如果没有覆盖基类中的某个虚函数，该虚函数行为类似其他成员，则会直接继承其在基类中的版本。

派生类可以在它覆盖的函数前使用 `virtual` 关键字，但不是必须。（15.3 节介绍）



#### 派生类对象及派生类向基类的类型转换

C++ 标准没有明确规定派生类对象在内存中如何分布。

因为派生类对象中含有其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且能将基类的指针或引用绑定到派生类对象中的基类部分。

```cpp
Quote item; // 基类
Bulk_quote bulk; // 派生类
Quote *p = &item; // p 指向 Quote 对象
p = &bulk; // p 指向 bulk 的 Quote 部分
Quote &r = bulk; // r 绑定到 bulk 的 Quote 部分
```

这种转换称为派生类到基类的类型转换，编译器会隐式地执行这个转换。



#### 派生类构造函数

派生类不能直接初始化基类继承而来的成员，需要使用基类的构造函数来初始化基类部分。

派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作。

如果不特别指出会执行默认初始化。如果想使用其他的基类构造函数，需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。

首先初始化基类部分，然后按声明的顺序依次初始化派生类成员。



#### 派生类使用基类的成员

派生类可以访问基类的公有成员和受保护成员。

15.6 节进一步讨论作用域，目前只需了解派生类的作用域嵌套在基类的作用域之内。



#### 继承与静态成员

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。



#### 派生类的声明

派生类声明与其他类差别不大，包含类名但不包含它的派生列表。



#### 被用作基类的类

如果想将某个类用作基类，则该类必须已经定义而非仅仅声明。所以类不能派生它本身。

一个类是基类，同时它也可以是一个派生类。（大概指，层次的深度不止为 2）



#### 防止继承的发生

如果一个类不希望其他类继承它，C++11 提供了一个方法，在类名后跟一个关键字 `final` 。

如 `calss NoDerived final {...};` NoDerived 不能作为基类。



### 15.2.3 类型转换与继承

我们可以将基类的指针或引用绑定到派生类对象上。

这样就说明，当使用基类的引用（或指针）时，我们并不清楚该引用（或指针）所绑定对象的真实类型。

智能指针也支持派生类向基类的类型转换。



#### 静态类型与动态类型

使用存在继承关系的类型时需要区分『静态类型』和『动态类型』。静态类型在编译时总是已知，动态类型直到运行时才可知。



#### 不存在从基类向派生类的隐式类型转换

因为基类的对象可能是派生类对象的一部分，也可能不是，所以没有从基类到派生类的自动类型转换。

即使一个基类指针或引用绑定在一个派生类对象上，也不能执行从基类向派生类的转换。

如果已知某个基类向派生类转换是安全的可以使用 `static_cast` 来转换。



#### 在对象之间不存在类型转换

派生类向基类的自动类型转换只对指针或引用类型有效。

合成版本的拷贝和赋值操作是 const 版本的引用，所以通常允许以派生类对象为参数。

当我们用派生类对象为基类对象初始化或赋值，只有派生类中基类部分会被拷贝、移动、赋值，其他部分会被忽略。



## 15.3 虚函数

所有虚函数都必须有定义，不管是否被使用。因为编译器无法确定到底会使用哪个虚函数，直到运行时才能确定。



#### 对虚函数的调用可能在运行时才被解析

当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。



#### 派生类中的虚函数

一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。

同样返回类型也必须与基类函数匹配，该规则存在一个例外。虚函数返回类型是类本身的指针或引用时，上述规则无效。

如，D 由 B 派生得到，B 虚函数返回 B\*，D 可以返回 D\*，需要满足 D 到 B 的类型转换可访问（15.5 节介绍）。



#### final 和 override 说明符

如果派生类定义了与基类中虚函数名相同的函数，但形参列表不同，仍然合法，只不过派生类函数没有覆盖基类中版本。

根据实际编程习惯这种声明往往意味着发生错误，想要调试这种错误比较麻烦，在 C++11 中可以使用 `override` 关键字来说明派生类中的虚函数。被标记的函数如果没有覆盖到虚函数，编译器会报错。

还能将某个函数指定为 `final` ，如果被指定为 final 的函数，派生类中不允许出现覆盖。出现会引发错误。

`final` 和 `override` 说明符出现在形参列表（包括任何 const 或 引用修饰符）以及尾置返回类型之后。



#### 虚函数与默认实参

虚函数可以有默认实参，如果某次函数调用使用了默认实参，则该实参由本次调用的静态类型决定（而非实际运行的类型）。

如果虚函数使用默认实参，基类和派生类中的默认实参最好一致。



#### 回避虚函数的机制

某些情况，可能希望对虚函数的调用不要进行动态绑定，而是强迫执行某个特定版本的虚函数。使用作用域运算符可以实现这功能。

`double und = baseP->Quote::net_price(42);`

这代码强行调用 Quote 的 net_price 函数，而不管 baseP 实际的对象类型。

通常使用情况在，派生类的虚函数需要调用基类函数版本。



## 15.4 抽象基类

#### 纯虚函数

纯虚函数：无须定义，没有实际意义。在声明语句分号前加上 `=0` 即可。 `=0` 只能出现在类内部的虚函数声明语句处。

声明了纯虚函数的类是抽象类，不能被用户创建实例。

可以为纯虚函数提供定义，不过函数体必须定义在类外。



#### 含有纯虚函数的类是抽象基类

抽象基类：含有纯虚函数的类。负责定义接口，后续的其他类可以覆盖该接口。不能创建抽象基类的对象。

抽象基类的派生类需要提供纯虚函数的定义，不然派生类还是抽象基类。



#### 派生类构造函数只初始化它的直接基类



## 15.5 访问控制与继承

#### 受保护的成员

`protected` 关键字声明那些希望派生类（友元）能够访问，用户不能访问的成员。

派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。



#### 公有、私有和受保护继承

派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没有什么影响。对基类成员的访问权限只与基类中的访问说明符有关。

派生访问说明符的目的是，控制派生类用户（包括派生类的派生类）对于基类成员的访问权限。

（大概就是对继承而来的类的访问类型说明）



#### 派生类向基类转换的可访问性

假定 D 继承自 B。

+ 只有 D 公有继承 B，用户代码才能使用派生类向基类的转换。
+ 不论 D 以什么方式继承 B，D 的成员函数和友元都能使用派生类向基类的转换。
+ 如果 D 继承 B 是公有或受保护，则 D 的派生类的成员和友元可以使用 D 向 B 类型转换。

（大致就是，对基类访问权限 == 用户直接对基类对象的访问权限，这种情况是可以类型转换的）



#### 友元与继承

友元关系不能被继承。每个类负责控制各自成员的访问权限。

一个基类的友元，可以访问继承该基类的派生类对象中基类部分。



#### 改变个别成员的可访问性

通过 `using` 声明可以达到这目的。

`using Base::size` 如果这行在 `public` 的访问说明符控制范围内，则继承 Base 的 size 是通过 `public` 继承的。

派生类只能为那些它可以访问的名字提供 using 声明



#### 默认的继承保护级别

class 关键字定义的派生类默认私有继承；

struct 关键字定义的派生类默认是公有继承。

人们常常有种错觉，认为 struct 和 class 关键字定义的类之间有更深层次差异。事实上唯一差别就是，默认成员访问说明符及默认派生访问说明符。（struct 主要是兼容 C，模板中好像有 class 特有功能）

私有派生的类最好显式将 private 声明出来，而不要仅仅依赖默认的设置。



## 15.6 继承中的类作用域

类作用域存在继承关系，派生类的作用域嵌套在基类作用域中。



#### 在编译时进行名字查找

一个对象、引用、指针的静态类型决定该对象的哪些成员可见，即使静态类型和动态类型不一致。



#### 名字冲突与继承

和其他作用域一样，派生类能重用定义在基类中的名字，内层作用域（派生类）会隐藏外层作用域（基类）的名字。



#### 通过作用域运算符来使用隐藏的基类成员

用作用域运算符可以使用被隐藏的基类成员。

除了虚函数之外，派生类中最好不要重用基类中的名字。



#### 名字查找优先于类型检查

声明在内层作用域的函数不会重载声明在外层作用域的函数。因此，派生类中的函数不会重载基类中的成员。如果派生类中成员与基类中的某个成员同名，则派生类将在其作用域内隐藏该基类成员，即使形参列表不一致。



#### 虚函数与作用域

Q：基类与派生类的虚函数为什么要有相同的形参列表？

A：如果不同，则无法通过基类的引用或指针调用派生类的虚函数。



#### 通过基类调用隐藏的虚函数

略



#### 覆盖重载的函数

派生类可以覆盖基类重载函数，如果有时仅需要覆盖重载集合中的一些而非全部函数，如果我们不得不覆盖每一个版本显得麻烦。

可以使用 `using` 语句声明。 `using` 声明语句指定一个名字不指定形参列表，会将所有重载的函数添加到派生类作用域，此时只需派生类定义其特有函数即可。

类内 using 声明一般规则（15.5 节）同样适用重载函数的名字。基类函数的实例在派生类中需要可访问，对派生类没有重新定义的重载版本的访问实际上是对 using 声明点的访问。



## 15.7 构造函数与拷贝控制

### 15.7.1 虚析构函数

基类通常应该定义一个虚析构函数，这样就能动态分配继承体系中的对象了。

如果不是虚析构函数，可能发生静态类型与动态类型不符情况，无法执行正确的析构函数版本（删除指向派生类对象的基类指针）。



#### 虚析构函数将阻止合成移动操作

基类定义了虚析构函数会对基类和派生类的定义产生一个间接影响：如果一个类定义了析构函数，编译器不会为这个类合成移动操作。



### 15.7.2 合成拷贝控制与继承

基类或派生类的合成拷贝控制成员的行为与其他合成的拷贝控制成员函数类似：

对类本身的成员依次进行初始化、赋值或销毁。合成版本还负责使用直接基类中对应的操作对直接基类部分进行初始化、赋值或销毁。

派生类合成的拷贝控制成员要求相应的基类成员（无论是合成还是自定义版本）能够访问，并且不是一个被删除的函数。



#### 派生类中删除的拷贝控制与基类的关系

+ 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符、析构函数是被删除的函数或不可访问，则派生类中对应的成员也将是被删除的。因为编译器不能使用基类成员来执行派生类对象中基类部分的构造、赋值、拷贝。
+ 如果基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的。因为编译器无法销毁派生类对象的基类部分。
+ 使用 `=default` 请求函数操作，如果基类中对应操作是删除的或不可访问的，那么派生类中将是删除的。



#### 移动操作与继承

大多数基类会定义虚析构函数，因此默认情况下，基类及派生类通常不含有合成的移动操作。

所以确实需要移动操作时，应该首先在基类中定义。一旦定义移动操作，拷贝操作也需要显式定义。



### 15.7.3 派生类的拷贝控制成员

类似派生类构造函数，派生类拷贝和移动构造含函数在拷贝和移动自有成员同时，也要拷贝和移动基类部分。

类似的派生类赋值运算符也必须为其基类部分的成员赋值。

与构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源，基类部分是自动销毁。



#### 定义派生类的拷贝或移动构造函数

拷贝或移动基类部分，需要显式使用基类的拷贝或移动构造函数。否则基类部分将会被默认初始化。

```cpp
class Base {};
class D: public Base {
public:
    D(const D &d): Base(d) {}
    D(D &&d): Base(std::move(d)) {}
}
```



#### 派生类赋值运算符

与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值。

```cpp
// Base::operator=(const Base &) 不会被自动调用
D &D::operator=(const D &rhs) {
    Base::operator=(rhs); // 为基类部分赋值
    ...
    return *this;
}
```



#### 派生类析构函数

因为派生类会隐式销毁基类部分，所以派生类析构函数只需负责销毁派生类自己分配的资源。

销毁顺序与创建顺序相反，从派生类开始向基类销毁。



#### 在构造函数和析构函数中调用虚函数

在类型构造或析构过程中，需要把对象的类和构造函数的类看作同一个。构造函数或析构函数调用某个虚函数，则执行与构造函数或析构函数所属类型相应的虚函数版本。

因为要避免未定义行为，如构造基类部分时不能使用派生类的虚函数。



### 15.7.4 继承的构造函数

C++11 新标准中派生类能够重用其直接基类定义的构造函数。

派生类继承基类构造函数方式是提供一条注明了（直接）基类名的 using 声明语句。

`using Disc_quote::Disc_quote` 继承了 Disc_quote 的构造函数。

编译器会对基类的构造函数生成一个与之对应的派生类构造函数（形参列表完全相同），派生类自己的数据成员会被默认初始化。

形如：`derived(parms) : base(args) {}`

类不能继承默认、拷贝和移动构造函数，如果派生类没定义这些构造函数，编译器将为派生类合成它们。



#### 继承的构造函数的特点

+ 和普通成员的 using 声明不同，构造函数的 using 声明不会改变构造函数的访问级别。

如不论 using 声明在哪，基类的私有构造函数在派生类中还是一个私有构造函数。

+ 继承的构造函数 using 声明语句不能指定 explicit 或 constexpr，和基类的属性相同。
+ 当基类构造函数有默认实参，实参不会被继承，而是派生类将获得多个继承的构造函数。（每个构造函数分别省略掉一个含有默认实参的形参）
+ 基类有多个构造函数，除了两个情况，大多数派生类会继承全部构造函数。
  + 第一种情况，派生类可以继承一部分构造函数，其他构造函数定义自己的版本。
  + 第二种情况，默认、拷贝、移动构造函数不会被继承。



## 15.8 容器与继承

容器存放继承体系中的对象时，通常必须采取间接存储的方式。

如果是存储派生类，则基类无法转换成派生类；如果存储基类，派生类对象被赋值给基类对象时，派生类部分会被『切掉』。



#### 在容器中放置（智能）指针而非对象

希望在容器中存放具有继承关系的对象时，实际上存放的通常是基类的（智能）指针。



### 15.8.1 编写 Basket 类

C++ 面向对象编程，通常无法直接使用对象进行面向对象编程，需要借助指针或引用。

由于使用指针会增加程序的复杂性，通常定义辅助的类来处理这种情况。

代码略（还介绍隐藏指针拷贝时，类型无法确定的解决方法：大意拷贝对象传入后，调用虚函数分辨拷贝类型）



## 15.9 文本查询程序再探

看看过，代码略



## 小结

略

