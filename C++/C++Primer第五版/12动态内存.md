# 12 动态内存

动态分配的对象的生成期与在哪里创建无关，只有显示地被释放时，这些对象才会销毁。

为了安全的使用动态对象，标准库定义了两个智能指针来管理动态分配的对象。



## 12.1 动态内存与智能指针

new 为对象分配空间并返回一个指向该对象的指针；delete 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

为了更容易（更安全）地使用动态内存，新的标准库（C++ 11）提供了两种智能指针类型管理动态对象。

智能指针的行为类似常规指针，重要的区别是它负责自动释放所指对象。

两种智能指针的区别在于管理底层指针的方式，`shared_ptr` 允许多个指针指向同一个对象，`unique_ptr` 『独占』所指的对象。

标准库还定义了 `weak_ptr` 的伴随类，是一种弱引用，指向 `shared_ptr` 所管理的对象。以上三种类型都定义在 `memory` 头文件中。



### 12.1.1 shared_ptr 类

类似 vector 智能指针也是模板，创建智能指针方法如下。

```cpp
shared_ptr<string> p1;
shared_ptr<list<int>> p2;
```

默认初始化的智能指针中包含一个空指针，12.1.3 节中介绍初始化智能指针的其他方法。

下表是 shared_ptr 和 unique_ptr 都支持的操作

| 操作                                   | 功能                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| shared_ptr\<T> sp 或 unique_ptr\<T> up | 空智能指针，可以指向类型为 T 的对象                          |
| p                                      | 将 p 用作一个条件判断，p 指向一个对象为 true                 |
| *p                                     | 解引用，获得它指向的对象                                     |
| p->mem                                 | 等价于(*p).mem                                               |
| p.get()                                | 返回 p 中保存的指针，注意若智能指针释放其对象，返回的指针所指向的对象也消失了 |
| swap(p,q) 或 p.swap(q)                 | 交换 p 和 q 中的指针                                         |

下表是 shared_ptr 的独有操作

| 操作                  | 功能                                                         |
| --------------------- | ------------------------------------------------------------ |
| make_shared\<T>(args) | 返回一个 shared_ptr 指向一个动态分配的类型为 T 的对象，用 args 初始化此对象 |
| shared_ptr\<T> p(q)   | p 是 shared_ptr q 的拷贝，会增加 q 中的计数器，q 中指针需要能转换为 T* |
| p = q                 | p 和 q 都是 shared_ptr，所保存的指针必须能够相互转换，会减少 p 的引用计数，增加 q 的引用计数。如果 p 引用计数变为 0，则将其管理的原内存释放。 |
| p.unique()            | 若 p.use_count() 为 1，返回 true，否则返回 false             |
| p.use_count()         | 返回与 p 共享对象的智能指针数量；可能很慢，主要用于调试。    |



#### make_shared 函数

make_shared 动态内存中分配一个对象并初始化它，返回此对象的 shared_ptr。

```cpp
shared_ptr<int> p3 = make_shared<int>(42);
shared_ptr<string> p4 = make_shared<string>(10, '9'); // "999999999"
auto p5 = make_shared<vecotr<string>>();
```



#### shared_ptr 的拷贝和赋值

引用计数：有多少个指向当前对象的指针，计数器为 0 时，自动释放管理的对象。

拷贝和赋值会改变引用计数



#### shared_ptr 自动销毁所管理的对象

#### shared_ptr 自动释放相关联的内存

#### 使用了动态生成期的资源的类

使用动态内存的原因：

+ 不知道使用多少对象
+ 不知道对象准确类型
+ 多个对象间共享数据



#### 定义 StrBlob 类

代码详见 `StrBlob.h` 文件



### 12.1.2 直接管理内存

#### 使用 new 动态分配和初始化对象

```cpp
int *pi = new int; // 默认初始化，未定义
string *ps = new string; // 空 string
int *pi = new int(); // 值初始化，值为 0，类型名后加小括号即可
int *pi = new int(1024); // pi 指向的对象值为 1024
string *ps = new string(10, '9'); // *ps 为 "999999999"
vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9}; // C++11 新特性列表初始化，花括号
aotu p1 = new auto(obj); // 推断 obj 类型，括号中只有单一初始化器才可以使用
```



#### 动态分配的 const 对象

```cpp
const int *pci = new const int(1024);
const string *pcs = new const string;
```

必须初始化，string 已经存在默认构造函数进行隐式初始化。



#### 内存耗尽

new 可能失败，抛出 bad_alloc 的异常。可以改变 new 使用方式阻止抛出异常。

```cpp
int *p1 = new int; // 失败抛出异常
int *p2 = new (nothrow) int; // 如果分配失败，new 返回一个空指针，这种形式的 new 称为定位 new
```



#### 释放动态内存

`delete p` p 必须指向一个动态分配的对象或是一个空指针

delete 分两个动作执行：销毁指向的对象，释放对应内存。



#### 指针值和 delete

编译器不能分辨一个指针指向的是静态还是动态分配的对象，也不能分辨一个指针指向的内存是否已经释放，大多数编译器会编译通过，虽然是错误的。

const 对象的值不能被更改，但是它本身能被销毁。



#### 动态对象的生存期直到被释放为止

内置指针（不是智能指针）管理的动态内存在被显示释放前会一直存在。

使用 new 和 delete 管理动态内存存在三个常见问题：

+ 忘记 delete 内存，内存泄漏
+ 使用已经释放掉的对象
+ 同一块内存释放两次



#### delete 之后重置指针值

空悬指针：delete 之后指针指向无效的内存



### 12.1.3 shared_ptr 和 new 结合使用

待

