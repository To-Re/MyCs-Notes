# 13 拷贝控制

拷贝控制操作有五种成员：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数



## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

拷贝构造函数：如果一个构造函数的第一个参数是自身类类型的引用，且额外参数都有默认值，则此构造函数是拷贝构造函数。



#### 合成拷贝构造函数

编译器会合成一个拷贝构造函数，一般情况，将对象的非 static 成员逐个拷贝到创建的对象。



#### 拷贝初始化

直接初始化，是使用参数最匹配的构造函数。

拷贝初始化，将右侧运算对象拷贝到正在创建的对象中，通常由拷贝构造函数完成（有时移动构造函数）。

拷贝初始化在下列情况发生：

+ 用 = 定义变量时
+ 将一个对象作为实参传递给一个非引用类型的形参
+ 从一个返回类型为非引用类型的函数返回一个对象
+ 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
+ 某些类类型还会对它们所分配的对象使用拷贝初始化。（例如，insert 或 push 元素时）



#### 参数和返回值

拷贝构造函数自己的参数是引用类型，因为必须函数调用过程不是实参会触发拷贝构造函数，导致无限递归。



#### 拷贝初始化的限制

如果添加 explicit 必须显示调用。



#### 编译器可以绕过拷贝构造函数

在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。即使跳过，拷贝/移动构造函数也必须存在且可访问。



### 13.1.2 拷贝赋值运算符

与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。



#### 重载赋值运算符

重载运算符本质上是函数，operator 后接要定义的的运算符。因此赋值运算符就是一个名为 `operator=` 的函数。

如果一个运算符是成员函数，对于二元运算符，例如 `=` ，左侧对象绑定到隐式的 this 参数，右侧运算符对象作为显式参数传递。返回值通常是一个指向左侧运算对象的引用。



#### 合成拷贝赋值运算符

如果类未定义自己的拷贝赋值运算符，编译器会生成一个合成拷贝赋值运算符。类似拷贝构造函数，将右侧对象的非 static 成员赋予左侧运算对象。



### 13.1.3 析构函数

析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值和参数。因此不能重载，一个类只有一个析构函数。



#### 析构函数完成什么工作

构造函数成员初始化在函数体之前完成，按类中出现顺序进行初始化。

在析构函数中，首先执行函数体，然后按初始化顺序的逆序销毁成员。

通常析构函数用来释放对象在生成期分配的所有资源。比如隐式销毁一个内置指针类型的成员，不会 delete 它指向的对象。智能指针是类类型，具有析构函数。



#### 什么时候会调用析构函数

无论何时一个对象被销毁，就会自动调用其析构函数。

注意：指向一个对象的引用或指针离开作用域时，不会执行析构函数。



#### 合成析构函数

类未定义析构函数时，编译器为它定义一个合成析构函数。`~类名(){}`



### 13.1.4 三/五法则

三个基本操作可以控制类的拷贝：拷贝构造函数、拷贝赋值运算符、析构函数。

新标准多了：移动构造函数、移动赋值运算符（13.6 节介绍）



#### 需要析构函数的类也需要拷贝和赋值操作

决定一个类是否要定义自己版本的拷贝控制成员时，一个基本原则是先确定这个类是否需要一个析构函数。通常对析构函数的需求比对拷贝构造函数或赋值运算符的需求更明显。

如类中存在内置指针发生浅拷贝引发错误。



#### 需要拷贝操作的类也需要赋值操作，反之亦然

略



### 13.1.5 使用 =default

可以通过将拷贝控制成员定义为 `=default` 来显示地要求编译器生成合成的版本。

类内用 `=default` 修饰成员的声明时，合成的函数将隐式地声明为内联的，如果不希望合成内联函数，需要在类外定义使用 `=default`



### 13.1.6 阻止拷贝

例如 iostream 类阻止了拷贝。



#### 定义删除的函数

新标准（c++11）下，可以通过将拷贝构造函数和拷贝赋值运算符定义为『删除的函数』来阻止拷贝。在参数列表后面加上 `=delete` 即可，通知编译器不定义这些成员。



#### 析构函数不能是删除的成员

可以编译运行，但是无法销毁。目前不知道作用。

析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。



#### 合成的拷贝控制成员可能是删除的

如果一个类有数据成员不能默认构造、拷贝、复制（感觉是说赋值）、销毁，则对应的成员函数将被定义为删除的。



#### private 拷贝控制

新标准前，类阻止拷贝通过将拷贝构造函数和拷贝赋值运算符声明为 private 来实现。

但是友元仍然能拷贝对象，所以声明为 private，且不定义它们。但如果调用链接阶段仍会发生错误。



## 13.2 拷贝控制和资源管理

定义类成员首先需要确认此类型对象的拷贝语义。一般有两种：

+ 像值，副本和原对象独立。深拷贝
+ 像指针，副本和原对象使用相同底层数据。浅拷贝

如何拷贝指针成员决定了是类值行为还是类指针行为。



### 13.2.1 行为像值的类

深拷贝

拷贝构造函数，需要完成指针指向的元素的拷贝；

析构函数，需要完成指针指向的元素的释放；

拷贝赋值运算符，需要完成释放当前对象指针指向的元素，然后完成右侧对象的拷贝；



#### 类值拷贝赋值运算符

销毁左侧运算对象的资源，从右侧运算对象拷贝数据。

注意：

+ 对象赋予自身，赋值运算符必须能正确工作（不要先 delete）
+ 大多数赋值运算符组合了析构函数和拷贝构造函数的工作



### 13.2.2 定义行为像指针的类

只有当最后一个指向元素的指针销毁时，才可以释放。最好使用 shared_ptr 来管理类中的资源。如果希望直接管理资源，需要使用『引用计数』。

引用计数的工作方式如下：

+ 每个构造函数（拷贝构造函数除外）还要创建一个引用计数，初始化计数器为 1。
+ 拷贝构造函数，递增计数器。
+ 析构函数，递减计数器，如果计数器为 0，则释放状态。
+ 拷贝赋值运算符递增右侧运算符对象的计数器，递减左侧运算符对象的计数器。如果左侧计数器变为 0，则销毁。



Q：如何存放计数器？

A：一种方法是将计数器保存在动态内存中。创建对象时，分配新的计数器；拷贝或赋值对象时，拷贝指向计数器的指针。

注意：拷贝赋值运算符必须能处理自赋值。



## 13.3 交换操作

管理资源的类通常还定义了一个名为 swap 的函数，对于那些与重排元素顺序的算法一起使用的类，定义 swap 非常重要，因为交换元素会用到。

可以定义一个自己版本的 swap 来重载默认的 swap。（交换具体的指针，而不是通过拷贝交换）



#### 在赋值运算符中使用 swap

拷贝并交换技术，这种技术将左侧对象与右侧运算对象的一个副本进行交换。

赋值运算符结束时，右侧对象会被销毁析构（原左侧对象）。这个技术自动处理了自赋值情况且天然就是异常安全的。



## 13.4 拷贝控制示例

看看过，没有实际动手。大概用了本章前面几节的大部分知识。



## 13.5 动态内存管理类

待

