# 13 拷贝控制

拷贝控制操作有五种成员：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数



## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

拷贝构造函数：如果一个构造函数的第一个参数是自身类类型的引用，且额外参数都有默认值，则此构造函数是拷贝构造函数。



#### 合成拷贝构造函数

编译器会合成一个拷贝构造函数，一般情况，将对象的非 static 成员逐个拷贝到创建的对象。



#### 拷贝初始化

直接初始化，是使用参数最匹配的构造函数。

拷贝初始化，将右侧运算对象拷贝到正在创建的对象中，通常由拷贝构造函数完成（有时移动构造函数）。

拷贝初始化在下列情况发生：

+ 用 = 定义变量时
+ 将一个对象作为实参传递给一个非引用类型的形参
+ 从一个返回类型为非引用类型的函数返回一个对象
+ 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
+ 某些类类型还会对它们所分配的对象使用拷贝初始化。（例如，insert 或 push 元素时）



#### 参数和返回值

拷贝构造函数自己的参数是引用类型，因为必须函数调用过程不是实参会触发拷贝构造函数，导致无限递归。



#### 拷贝初始化的限制

如果添加 explicit 必须显示调用。



#### 编译器可以绕过拷贝构造函数

在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。即使跳过，拷贝/移动构造函数也必须存在且可访问。



### 13.1.2 拷贝赋值运算符

与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。



#### 重载赋值运算符

重载运算符本质上是函数，operator 后接要定义的的运算符。因此赋值运算符就是一个名为 `operator=` 的函数。

如果一个运算符是成员函数，对于二元运算符，例如 `=` ，左侧对象绑定到隐式的 this 参数，右侧运算符对象作为显式参数传递。返回值通常是一个指向左侧运算对象的引用。



#### 合成拷贝赋值运算符

如果类未定义自己的拷贝赋值运算符，编译器会生成一个合成拷贝赋值运算符。类似拷贝构造函数，将右侧对象的非 static 成员赋予左侧运算对象。



### 13.1.3 析构函数

析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值和参数。因此不能重载，一个类只有一个析构函数。



#### 析构函数完成什么工作

构造函数成员初始化在函数体之前完成，按类中出现顺序进行初始化。

在析构函数中，首先执行函数体，然后按初始化顺序的逆序销毁成员。

通常析构函数用来释放对象在生成期分配的所有资源。比如隐式销毁一个内置指针类型的成员，不会 delete 它指向的对象。智能指针是类类型，具有析构函数。



#### 什么时候会调用析构函数

无论何时一个对象被销毁，就会自动调用其析构函数。

注意：指向一个对象的引用或指针离开作用域时，不会执行析构函数。



#### 合成析构函数

类未定义析构函数时，编译器为它定义一个合成析构函数。`~类名(){}`



### 13.1.4 三/五法则

三个基本操作可以控制类的拷贝：拷贝构造函数、拷贝赋值运算符、析构函数。

新标准多了：移动构造函数、移动赋值运算符（13.6 节介绍）



#### 需要析构函数的类也需要拷贝和赋值操作

决定一个类是否要定义自己版本的拷贝控制成员时，一个基本原则是先确定这个类是否需要一个析构函数。通常对析构函数的需求比对拷贝构造函数或赋值运算符的需求更明显。

如类中存在内置指针发生浅拷贝引发错误。



#### 需要拷贝操作的类也需要赋值操作，反之亦然

略



### 13.1.5 使用 =default

可以通过将拷贝控制成员定义为 `=default` 来显示地要求编译器生成合成的版本。

类内用 `=default` 修饰成员的声明时，合成的函数将隐式地声明为内联的，如果不希望合成内联函数，需要在类外定义使用 `=default`



### 13.1.6 阻止拷贝

例如 iostream 类阻止了拷贝。



#### 定义删除的函数

新标准（c++11）下，可以通过将拷贝构造函数和拷贝赋值运算符定义为『删除的函数』来阻止拷贝。在参数列表后面加上 `=delete` 即可，通知编译器不定义这些成员。



#### 析构函数不能是删除的成员

可以编译运行，但是无法销毁。目前不知道作用。

析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。



#### 合成的拷贝控制成员可能是删除的

如果一个类有数据成员不能默认构造、拷贝、复制（感觉是说赋值）、销毁，则对应的成员函数将被定义为删除的。



#### private 拷贝控制

新标准前，类阻止拷贝通过将拷贝构造函数和拷贝赋值运算符声明为 private 来实现。

但是友元仍然能拷贝对象，所以声明为 private，且不定义它们。但如果调用链接阶段仍会发生错误。



## 13.2 拷贝控制和资源管理

定义类成员首先需要确认此类型对象的拷贝语义。一般有两种：

+ 像值，副本和原对象独立。深拷贝
+ 像指针，副本和原对象使用相同底层数据。浅拷贝

如何拷贝指针成员决定了是类值行为还是类指针行为。



### 13.2.1 行为像值的类

深拷贝

拷贝构造函数，需要完成指针指向的元素的拷贝；

析构函数，需要完成指针指向的元素的释放；

拷贝赋值运算符，需要完成释放当前对象指针指向的元素，然后完成右侧对象的拷贝；



#### 类值拷贝赋值运算符

销毁左侧运算对象的资源，从右侧运算对象拷贝数据。

注意：

+ 对象赋予自身，赋值运算符必须能正确工作（不要先 delete）
+ 大多数赋值运算符组合了析构函数和拷贝构造函数的工作



### 13.2.2 定义行为像指针的类

只有当最后一个指向元素的指针销毁时，才可以释放。最好使用 shared_ptr 来管理类中的资源。如果希望直接管理资源，需要使用『引用计数』。

引用计数的工作方式如下：

+ 每个构造函数（拷贝构造函数除外）还要创建一个引用计数，初始化计数器为 1。
+ 拷贝构造函数，递增计数器。
+ 析构函数，递减计数器，如果计数器为 0，则释放状态。
+ 拷贝赋值运算符递增右侧运算符对象的计数器，递减左侧运算符对象的计数器。如果左侧计数器变为 0，则销毁。



Q：如何存放计数器？

A：一种方法是将计数器保存在动态内存中。创建对象时，分配新的计数器；拷贝或赋值对象时，拷贝指向计数器的指针。

注意：拷贝赋值运算符必须能处理自赋值。



## 13.3 交换操作

管理资源的类通常还定义了一个名为 swap 的函数，对于那些与重排元素顺序的算法一起使用的类，定义 swap 非常重要，因为交换元素会用到。

可以定义一个自己版本的 swap 来重载默认的 swap。（交换具体的指针，而不是通过拷贝交换）



#### 在赋值运算符中使用 swap

拷贝并交换技术，这种技术将左侧对象与右侧运算对象的一个副本进行交换。

赋值运算符结束时，右侧对象会被销毁析构（原左侧对象）。这个技术自动处理了自赋值情况且天然就是异常安全的。



## 13.4 拷贝控制示例

看看过，没有实际动手。大概用了本章前面几节的大部分知识。



## 13.5 动态内存管理类

某些类需要自己进行内存分配。介绍了使用 allocator 如何实现动态内存管理类。还介绍具体拷贝构造函数、析构函数、拷贝赋值函数等该如何实现。

还提到移动构造函数和 std::move，需要分配新内存时，拷贝指针，指针指向的值不拷贝。（大概是这意思，避免额外的开销）

```cpp
// reallocate
void StrVec::reallocate() {
    // 分配新内存
    auto newcapacity = size() ? 2 * size() : 1;
    auto newdata = alloc.allocate(newcapacity);
    // 移动拷贝
    auto dest = newdata;
    auto elem = elements;
    for (size_t i = 0; i != size(); ++i)
        alloc.construct(dest++, std::moce(*elem++));
    // 释放旧内存空间
    free();
    // 更新其他类内数据
    elements = newdata;
    first_free = dest;
    cap = elements+newcapacity;
}
```



## 13.6 对象移动

使用移动而不是拷贝的原因：

+ 有些对象移动而非拷贝会大幅度提升性能
+ 有些对象不能拷贝，如 IO 类或 unique_ptr，但可以移动

旧版本标准库，没有直接的方法移动对象，容器保存的类必须是可拷贝的。新标准中可以保存不可拷贝的类型，只要它们能被移动即可。



### 13.6.1 右值引用

右值引用：必须绑定到右值的引用。

右值引用一个重要性质，只能绑定到一个将要销毁的对象。

右值引用或 const 左值引用可以绑定到右值。



#### 左值持久；右值短暂

左值引用有持久的状态，右值引用只能绑定到临时对象



#### 变量是左值

变量可以看作没有运算符的表达式，不能将一个右值引用绑定到一个右值引用类型的变量上

```cpp
int &&rr1 = 42; // ture
int &&rr2 = rr1; // false
```



#### 标准库 move 函数

虽然不能将右值引用绑定到一个左值上，但是可以显示地将左值转换为对应的右值引用类型。

还可以通过调用 `move` 新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件 `utility` 中。

`int &&rr3 = std::move(rr1);`

调用 move 意味着除了对 rr1 赋值或销毁外，不能再使用它。即可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。

对 move 不提供 using 声明，调用是 `std::move` 而不是 `move` 原因 18.2.3 节介绍。



### 13.6.2 移动构造函数和移动赋值运算符

让自己的类型支持移动操作，需要定义移动构造函数和移动赋值运算符。

移动构造函数的第一个参数是该类类型的一个右值引用，任何额外的参数都必须有默认实参。（与拷贝构造相似，拷贝构造左值引用）

```cpp
StrVec::StrVec(StrVec &&s) noexcept // 移动操作不应抛出任何异常
    : elements(s.elements), first_free(s.first_free), cap(s.cap) {
    s.elements = s.first_free = s.cap = nullptr;
    // 令 s 进入这样状态——对其运行析构函数是安全的
}
```

noexcept，通知标准库我们的构造函数不抛出任何异常。

与拷贝构造函数不同，移动构造函数不分配新内存，接管给定的 StrVec 中的内存。

接管内存之后，将给定对象中的指针置为 nullptr。完成从给定对象的移动操作。

最终，移后源对象会被销毁，意味着在其上运行析构函数。

如果忘记改变 `s.first_free` ，则销毁移后源对象就会释放掉刚刚移动的内存。



#### 移动操作、标准库容器和异常

noexcept 是 C++11 引入，承诺函数不抛出异常的一种方法。在函数的参数列表后面指定 noexcept。18.1.4 节讨论更多细节。

Q：为什么需要 noexcept

A：如 vector 重新分配内存时，移动部分元素后抛出一个异常会产生问题，vector 将不能满足自身保持不变的要求。如果是 vector 拷贝构造函数发生异常，可以容易地满足自身保持不变。所以想要使用移动构造函数必须显示告诉标准库我们的移动构造函数可以安全使用。



#### 移动赋值运算符

移动赋值运算符执行与析构函数和移动构造函数相同的工作。也需要被标记为 `noexcept` ，且能够正确处理自赋值。

`A& A::operator=(A &&rhs) noexcept {}`

直接检查 this 指针和 右值引用的地址是否相同来判断是否为自赋值。



#### 移后源对象必须可析构

对一个对象移动数据不会销毁此对象。但有时移动操作完成后，源对象会被销毁，所以编写移动操作时，必须确保移后源对象进入一个可析构的状态。如将移后源对象的指针成员置为 nullptr。

移动操作还需保证对象仍然有效，一般来说有效指可以安全为其赋予新值或者安全地使用而不依赖其当前值。

总结这一小段：

> 移动操作之后，移动源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。



#### 合成的移动操作

编译器也会合成移动构造函数和移动赋值运算符。

如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器不会为它合成移动构造函数和移动赋值运算符。

如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可移动，编译器才会合成移动构造函数或移动赋值运算符。



移动操作不会被隐式定义为删除的函数。但如果显示地要求 `=default` 且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。



如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。



#### 移动右值，拷贝左值

如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作类似。

```cpp
A getA(istream &); // getA 返回一个右值
v = getA(cin); // 移动赋值
```



#### 如果没有移动构造函数，右值也被拷贝

一个类有拷贝构造函数但未定义移动构造函数，这种情况编译器不会合成移动构造函数，意味着即使使用 `move` 也会选择拷贝构造函数。

拷贝构造函数代替移动构造函数几乎是安全的。



#### 拷贝并交换赋值运算符和移动操作

```cpp
class HasPtr {
public:
    HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) {p.ps = 0;}
    // 赋值运算符既是移动赋值运算符，也是拷贝赋值运算符
    HasPtr& operator= (HasPtr rhs) {
        swap(*this,rhs);
        return *this;
    }
    ...
}
// hp 和 hp2 是 HasPtr 对象
hp = hp2; // hp2 是左值，使用拷贝构造函数拷贝
hp = std::move(hp2); // 移动构造函数移动
```



建议：更新三/五法则。一般来说一个类定义任何一个拷贝操作，就应该定义所有五个操作



#### Message 类的移动操作

接 13.4 节代码，看看过。



#### 移动迭代器

移动迭代器解引用运算符生成一个右值引用。

`make_moce_iterator` 函数将一个普通迭代器转换为一个移动迭代器，此函数介绍一个迭代器参数，返回一个移动迭代器。

```cpp
for (size_t i = 0; i != size(); ++i)
        alloc.construct(dest++, std::moce(*elem++));
// 可替换为如下代码
auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);
```



不要随意使用移动操作，必须绝对确认移后源对象没有其他用户。



### 13.6.3 右值引用和成员函数

成员函数如果能提供拷贝和移动版本，它也能从中受益。通常这种成员函数采用类似拷贝/移动构造函数类似的参数模式——一个版本接受一个指向 const 的左值引用，第二个版本接受一个指向非 const 的右值引用。

例如 `push_back` 标准库容器提供两个版本

```cpp
void push_back(const X&); // 绑定任意类型 X
void push_back(X&&); // 只绑定类型 X 的可修改的右值
string s = "fuck";
v.push_back(s); // 左值引用
v.push_back("fuck") // 右值引用
```



#### 右值和左值引用成员函数

```cpp
(s1 + s2).find('a');
s1 + s2 = "fuck";
```

为了向后兼容新标准库类仍然允许向右赋值，但我们可能希望在自己的类中阻止这种方法，希望强制左侧运算对象是一个左值，可以使用『引用限定符』。

在参数列表后放置引用限定符即可。`&` 限定左值，`&&` 限定右值。且必须同时出现在函数的声明和定义中。

一个函数可以同时用 const 和 引用限定。引用限定必须跟随在 const 限定符之后。`Foo wtf() const &;`



#### 重载和引用函数

引用限定符可以区分重载版本。编译器会根据调用的对象的左值/右值属性来确认重载版本。

如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。

例子：sorted 要求返回 Foo 对象副本

```cpp
class Foo {
public:
    Foo sorted() &&; // 可用于可改变右值
    Foo sorted() const &;
private:
    vector<int> data;
}
Foo Foo::sorted() && { // 本对象为右值，所以直接对原址排序
    sort(data.begin(), data.end());
    return *this;
}
Foo Foo::sorted() && { // 本对象为 const 或 左值，不能对原址排序
    Foo ret(*this); // 拷贝副本
    sort(ret.data.begin(), ret.data.end());
    return ret;
}
```



## 小结

略

