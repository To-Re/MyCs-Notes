# 10 泛型算法

泛型：可以用于不同类型的元素和多种容器类型。



## 10.1 概述

大多数算法定义在头文件 `algorithm` 中，`numeric` 中也有一些数值泛型算法。

一般情况下，这些算法不直接操作容器，而是遍历由两个迭代器指定的一个元素范围。



#### 算法如何工作

如 `auto result = find(lst.cbegin(), lst.cend(), val);` 查找 lst 容器中的 val 值。

依赖于迭代器进行遍历操作（不依赖于容器）。

还依赖于元素类型的操作，如 find 中需要使用 `==` 运算符进行比较。

关键概念：泛型算法不依赖容器操作。



## 10.2 初始泛型算法

标准库提供许多算法，比起记忆算法，更需要记忆算法的统一原则。

除少数例外，标准库算法都对一个范围内的元素进行操作，我们将此元素范围称为『输入范围』。接受输入范围的算法总是使用前两个参数表示范围，这两个参数分别是，指向要处理的第一个元素和尾元素之后位置的迭代器。



### 10.2.1 只读算法

`int sum = accumulate(vec.cbegin(), vec.cend(), 0);` 求范围内的和，和初值设为 0。（需要元素类型存在 `+` 运算如 string）

`equal(r1.cbegin(), r1.cend(), r2.cbegin());` 比较两个序列是否保存相同的值。（第二个序列元素至少与第一个序列范围内元素一样多，还需要支持 `==` 运算符）



### 10.2.2 写容器元素的算法

算法不会执行容器操作，因此不会改变容器大小。

`fill(vec.begin(), vec.end(), 0);` 每个元素重置为 0。

算法不检查写操作，可能会产生越界问题。



#### 介绍 back_inserter

back_inserter 在头文件 iterator 中

back_inserter 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。

当通过此迭代器赋值时，赋值运算符会调用 push_back 将一个具有给定值的元素添加到容器中。

```cpp
vector<int> vec; // 空向量
auto it = back_inserter(vec); // 一个插入迭代器
*it = 42; // vec 中现在有一个元素，值为 42
```



`fill_n(back_inserter(vec), 10, 0)` ，vec 初始为一个空向量，通过插入迭代器添加了 10 个值为 0 的元素到 vec 中。



#### 拷贝算法

`auto ret = copy(begin(a1), end(a1), a2);` ，将一个输入范围内元素拷贝到目的序列，第三个参数是目的序列的起始位置。传递给 copy 的目的序列至少要包含与输入序列一样多的元素。

copy 返回的是其目的位置迭代器（递增后）的值。



`replace` 、`replace_copy` 略



### 10.2.3 重排容器元素的算法

`sort(a.begin(), b.begin());` 通过 `<` 运算符进行比较，实现排序。

`unique(a.begin, b.begin());` 消除相邻重复，返回最后一个不重复元素之后的位置。



## 10.3 定制操作

待

