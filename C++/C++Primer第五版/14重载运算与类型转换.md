# 14 重载运算与类型转换

## 14.1 基本概念

重载运算符和其他函数一样包含返回类型、参数列表、函数体。函数名由关键字 `operator` 加运算符号组成。

除了重载 `()` 其他重载运算符不能含有默认实参。

如果一个运算符函数是成员函数，则第一个（左侧）运算对象绑定到隐式的 `this` 指针上。

对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。`int operator+(int, int)` 是错误的。

可以重载大多数运算符，只能重载已有运算符，19.1.1 节介绍重载 new 和 delete 的方法。

`+-*&` 这四个运算符既是一元运算符也是二元运算符，根据参数的数量推断是那种。

不能被重载的运算符有 `::` 、`.*` 、`.` 、`?:`



#### 直接调用一个重载的运算符函数

```cpp
data1+data2;
operator+(data1, data2);
data1.operator+(data2);
```



#### 某些运算符不应该被重载

有些运算符指定了运算对象求值的顺序，不建议重载它们（逗号、取地址、逻辑与、逻辑或）。

如逻辑与/或运算符、逗号运算符，其运算对象求值顺序规则无法保留。比如 `&&` 中短路求值属性无法保留，两个运算对象总是会被求值。



#### 使用与内置类型一致的含义

+ 如果类执行 IO 操作，则定义移位运算符使其与内置类型的 IO 保持一致
+ 如果类执行检查相等性，则定义 `operator==` ，如果类有 `operator==` 通常也应该有 `operator!=`
+ 如果类有单序比较操作，则定义 `operator<` ，如果类有 `operator<` 通常也应该有其他关系操作
+ 重载运算符返回类型应该与内置版本的返回类型兼容。
  + 逻辑运算符和关系运算符应该返回 bool
  + 算术运算符应该返回类类型的值
  + 赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用



#### 赋值和符合运算符

赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。

如果含有算术运算符或位运算符，最好提供对应的复合赋值运算符。



#### 选择作为成员或者非成员

下面的准则帮助判断应该将运算符定义为成员函数还是非成员函数。

+ `=、[]、()、->` 必须是成员
+ 复合赋值运算符一般来说应该是成员
+ 改变对象状态的运算符或与给定类型密切相关的运算符，如递增、递减、解引用，通常是成员
+ 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算，通常是非成员函数



第四个准则的意思应该是，运算符左右两边元素类型可能不一致，如 `string("fu") + "ck"` ，所以需要定义为非成员函数，进行隐式转换。唯一要求是至少有一个运算对象是类类型。



## 14.2 输入和输出运算符

### 14.2.1 重载输出运算符 <<

由于输出流无法复制、写入会改变状态，所以第一个参数是非常量 ostream 引用。

第二个形参一般来说是一个常量引用，该常量是需要打印的类类型。

为了与其他输出运算符保持一致，返回值是 ostream 形参。

`ostream& operator<< (ostream &os, const Sales_data &item){...}`



#### 输出运算符尽量减少格式化操作

减少格式化操作有利于用户有权限控制输出的细节



#### 输入输出运算符必须是非成员函数

因为如果是类成员函数，左侧运算符将是类的一个对象。

所以需要定义为非成员函数。

IO 运算符通常读写类的非公用数据成员，所以一般被声明为友元



### 14.2.2 重载输入运算符 >>

类似重载 `<<` 运算符，第一个形参是将要读取流的引用，第二形参是将要写入的对象引用，返回流的引用。



输入运算符必须处理可能失败的情况。



#### 输入时的错误

可能有以下错误发生：

+ 错误的数据类型
+ 读到文件末尾



当读取操作发生错误时，输入运算符应该负责从错误中恢复



#### 标示错误

输入运算符设置 failbit 表示流被破坏，设置 eofbit 表示文件耗尽。最好的方式由 IO 标准库自己标示这些错误。



## 14.3 算术和关系运算符

通常把算术和关系运算符定义为非成员函数以允许对左侧或右侧的运算对象进行转换。因为一般不改变运算对象状态，形参通常是常量的引用。

`Sales_data operator+ (const Sales_data &lhs, const Sales_data &rhs){...}`



如果类同时定义了算术运算符和相关的复合赋值运算符，则通常应该使用复合赋值来实现算术运算符。

复合赋值来实现算术运算符大致操作即，声明临时变量拷贝第一个形参，复合赋值第二个形参，返回临时变量。



### 14.3.1 相等运算符

通常定义为 `operator==`

通常应该满足传递性，a == b 和 b == c 都为真，a == c 也为真

通常定义了 `operator==` 也要定义 `operator!=`

!= 和 = 的工作委托给其中一个，其中一个只需调用另一个真正工作的。



### 14.3.2 关系运算符

管理容器和一些算法要用到小于运算符，所以定义 `operator<` 会比较有用

关系运算符，应该定义顺序关系，且如果由  `!=` 运算符，那么如果两个对象 `!=` 则其中一个应该 `<` 另外一个。



## 14.4 赋值运算符

之前介绍过拷贝赋值和移动赋值。还可以定义接受花括号内的元素列表为参数的赋值运算。

`StrVec& operator= (iniitalizer_list<string>){...}`

无需检查自赋值，因为形参不是类。

返回左侧运算对象的引用。

赋值运算符不论形参类型是什么都必须定义为成员函数。



#### 复合赋值运算符

复合赋值运算符不非得是类的成员，不过倾向于定义在类内。

复合赋值运算符返回也是左侧运算对象的引用。



## 14.5 下标运算符

下标通常返回访问元素的引用。（这样可以时下标出现在赋值运算符的任意一端）

最好定义下标运算符的常量版本和非常量版本。

`const string& operator[] (size_t n) const {...}`

`string& operator[] (size_t n) {...}`



## 14.6 递增和递减运算符

不要求递增递减运算符必须是类的成员，但因为改变对象的状态，建议设定为成员函数。

递增递减运算符存在前置版本和后置版本。



#### 定义前置递增/递减运算符

`StrBlobPtr& operator++();` 前置运算符定义

前置运算符应该返回递增或递减后对象的引用。



#### 区分前置和后置运算符

后置版本接受一个额外的（不被使用）int 类型的形参。当我们使用后置运算符时，编译器为其提供一个值为 0 的实参。这个形参唯一的作用就是区分前置和后置版本的函数。

`StrBlobPtr operator++(int);` 后置运算符定义

后置运算符应该返回对象的原值（递增或递减前的值非引用）



#### 显式地调用后置运算符

```cpp
StrBlobPtr p(a1);
p.operator++(0); // 调用后置版本
p.orerator++(); // 调用前置版本
```

如果使用函数调用方式调用后置版本，传入的值会被忽略但必不可少，因为编译器靠其区分前置和后置版本。



## 14.7 成员访问运算符

`->` 和 `*` 解引用。箭头运算符必须是类的成员，解引用运算符通常是类的成员。

`string& operator* () const {...}`

`string* operator-> () const {...}`

可以将箭头运算符部分工作托付给解引用运算符。

```cpp
StrBlob a1 = {"hi", "bye", "now"};
StrBlobPtr p(a1);
*p = "okay";
cout << p->size() << endl;
cout << (*p).size() << endl;
```



#### 对箭头运算符返回值的限定

可以令 `operator*` 完成任何我们指定的操作（虽然这样不太好）。但箭头运算符则不行，它不能丢掉成员访问这个最基本的含义。

重载箭头可以改变箭头从哪个对象中获取成员，但是箭头获取成员这一事实永不改变。

比如 `point->mem` 根据 point 类型不同，分别等价于

```cpp
(*point).mem;
point.operator()->mem;
```

+ 如果 point 是指针，会对该指针解引用取得对象中指定成员
+ 如果 point 是对象，会先得到 point.operator->() 的结果，如果结果是指针执行第一步，如果结果含有重载 `operator->()` 重复调用。直到返回所需内容，或返回程序错误信息

重载的箭头运算符必须返回类的指针或自定义了箭头运算符的某个类的对象



## 14.8 函数调用运算符

如果类重载了函数调用运算符，则可以像使用函数一样使用该类的对象。

函数调用运算符必须是成员函数，可以存在多个不同版本的调用运算符，但需要有区别。

如果类定义了调用运算符，则称该类的对象为『函数对象』，因为可以像函数一样调用对象。

例子：

```cpp
struct absInt {
    int operator() (int val) const {
        return val < 0 ? -val : val;
    }
}
int i = -42;
absInt absObj;
int ui = absObj(i);
```



### 14.8.1 lambda 是函数对象

lambda 表达式会被翻译成一个未命名类的未命名对象，这个产生的类中含有一个重载的函数调用运算符。

例如：

```cpp
satble_sort(words.begin(), words.end(), [](const) string &a, const string &b) {
    return a. size() < b.size();
});
// 生成的类类似下面一个未命名对象
class ShorterString {
public:
    bool operator() (const string &s1, const string &s1) const {
        return s1.size() < s2.size();
    }
}
// 用这个类代替 lambda 表达式可以按如下方式重写 stable_sort
stable_sort(words.begin(), words.end(), ShorterString());
```



#### 表示 lambda 及相应捕获行为的类

引用捕获，无需在 lambda 产生的类中存储为数据成员。

值捕获，必须在 lambda 产生的类中为每个变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。

lambda 表达式产生的类不含默认构造函数、赋值运算符、默认析构函数。它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型。



### 14.8.2 标准库定义的函数对象

标准库定义了一组表示算术运算符、关系运算符、逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。

例如，plus 类定义了一个函数调用执行 `+` 操作；modulus 类定义了一个调用运算符执行 `%` 操作；equal_to 类执行 `==` ，等等。

这些类被定义模板形式。

```cpp
plus<int> intAdd;
int sum = intAdd(10, 20);
```

functional 头文件中有如下表的函数对象。

| 算术           | 关系              | 逻辑            |
| -------------- | ----------------- | --------------- |
| plus\<T>       | equal_to\<T>      | logical_and\<T> |
| minus\<T>      | not_equal_to\<T>  | logical_or\<T>  |
| multiplies\<T> | greater\<T>       | logical_not\<T> |
| divides\<T>    | greater_equal\<T> |                 |
| modulus\<T>    | less\<T>          |                 |
| negate\<T>     | less_equal\<T>    |                 |



#### 在算法中使用标准库函数对象

表示运算符的函数对象类常用来替换算法中的默认运算符。

默认情况下排序算法使用 `operator<` 进行升序排序。

`sort(svec.begin(), svec.end(), greater<string>());` 降序排序。

比较两个指针会产生未定义行为，但是想通过指针地址排序可以使用标准库函数对象实现。

`sort(svec.begin(), svec.end(), less<string*>());`

关联容器使用 less\<key_type> 对元素排序，因此可以定义指针的 set 无需声明 less。



### 14.8.3 可调用对象与 function

有几种可调用的对象：函数、函数指针、lambda 表达式、bind 创建的对象、重载函数调用运算符的类。

可调用对象也有类型，两个不同类型的可调用对象可能共享同一种调用形式（返回类型、传递实参类型），一种调用形式对应一个函数类型。



#### 不同类型可能具有相同的调用形式

函数表：用于存储指向这些可调用对象的『指针』，当程序需要某个特定操作时，从表中查找该调用的函数。

```cpp
// 普通函数
int add(int i, int j) {return i+j; }
// lambda
auto mod = [](int i, int j) {return i%j; };
// 函数对象类
struct divide {
    int operator() (int denominator, int divisor) {
        return denominator / divisor;
    }
}
// 都是同种调用形式 int(int, int)
// 函数表
map<string, int(*)(int, int)> binops;
binops.insert({"+", add}); // 正确
binops.insert({"%", mod}); // 错误，mod 不是函数指针，是 lambda 表达式
```



#### 标准库 function 类型

我们可以使用 `function` 标准库类型（C++11）解决上面的问题。 function 定义在 `functional` 头文件中。

| 操作                           | 功能                                                 |
| ------------------------------ | ---------------------------------------------------- |
| function\<T> f                 | f 是一个用来存储可调用对象的空 function              |
| function\<T> f(nullptr)        | 显示地构造一个空 function                            |
| function\<T> f(obj)            | 在 f 中存储可调用对象 obj 的副本                     |
| f                              | 将 f 作为条件：当 f 中含有一个可调用对象时为真       |
| f(args)                        | 调用 f 中的对象，参数是 args                         |
| 定义为 function\<T> 的成员类型 |                                                      |
| result_type                    | 该 function 类型的可调用对象返回的类型               |
| argument_type                  | 当 T 只有一个实参，则 argument_type 是该类型的同义词 |
| first_argument_type            | 当 T 有两个实参，fist 和 second 分别代表两个实参类型 |
| second_argument_type           |                                                      |

```cpp
function<int(int, int)> f1 = add; // 函数指针
function<int(int, int)> f2 = divide(); // 函数对象类的对象
function<int(int, int)> f3 = [](int i, int j) {return i * j; }; // lambda
cout << f1(4,2) << endl; // 6
cout << f2(4,2) << endl; // 2
cout << f3(4,2) << endl; // 8
```

使用这个 function 类型我们可以解决刚刚的问题（14.8.3.1）

```cpp
map<string, function<int(int, int)>> binops = {
    {"+", add},
    {"-", std::minus<int>()},
    {"/", divide()},
    {"*", [](int i, int j) {return i * j;} },
    {"%", mod}
};
binops["+"](10, 5); // 调用 add(10, 5)
```



#### 重载的函数与 function

不能直接将重载函数的名字存入 function 类型的对象中。

解决的一个方法是存储函数指针而非函数名字，或者使用 lambda 指定希望使用的版本。

```cpp
int (*fp)(int, int) = add;
binops.insert({"+", fp}); // fp 指向一个正确的 add 版本
binops.insert({"+", [](int a, int b) {return add(a, b);} });
```



## 14.9 重载、类型转换与运算符

### 14.9.1 类型转换运算符

类型转换运算符是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型。

函数一般形式如下：`operator type() const;`

type 可以面向任意类型进行定义（除了 void），只要该类型能作为函数的返回类型，所以不允许转换成数组或函数类型，但允许转换成指针（数组指针、函数指针）或引用类型。

类型转换函数必须是成员函数，不能声明返回类型，形参列表必须为空，函数通常应该是 const。



#### 定义含有类型转换运算符的类

```cpp
class SmallInt {
public:
    SmallInt(int i = 0): val(i) {...}
    operator int() const {return val;}
private:
    std::size_t val;
}

SmallInt si;
si = 4;
si + 3;
```



提示：避免过度使用类型转换函数



#### 类型转换运算符可能产生意外结果

类很少提供类型转换运算符，大多数情况下类型转换自动发生，用户会感到意外。定义向 bool 的类型转换还是比较普遍的现象。

隐式转换可能出现如下问题

```cpp
int i = 42;
cin << i; // 如果 bool 转换是隐式的，则该代码在编译器看起来是合法的
```



#### 显式的类型转换运算符

C++11 引入显式的类型转换运算符。

```cpp
class SmallInt {
public:
    explicit operator int() const {return val;}
    ...
}
SmallInt si = 3;
si + 3; // 错误
static_cast<int>(si) + 3; // 正确
```

类型转换无法隐式进行，除了一种情况，当表达式被用作条件，则会将显式的类型转换自动用于它。



#### 转换为 bool

早期标准库版本，IO 类型定义向 void* 的转换规则，避免上面的问题。

C++11 新标准，IO 标准库通过定义向 bool 的显式类型转换实现同样的目的。

向 bool 类型转换通常在条件部分，因此 `operator bool` 一般定义为 `explicit` 的。



### 14.9.2 避免有二义性的类型转换

必须确保类类型和目标类型之间只存在唯一一种转换方式。否则可能存在二义性。

确定转换方式需要考虑，类型转换运算规则，以及构造函数。

通常情况不要为类定义相同的类型转换，也不要在类中定义两个以上转换源或转换目标是算术类型的转换。



#### 实参匹配和相同的类型转换

例子：B 定义了转换成 A 的类型转换运算符，A 定义了以 B 为参数的构造函数。

```cpp
A f(const A&); // 一个函数
B b;
A a = f(b); // 二义性错误
A a1 = f(b.operator A()); // 正确，使用 B 的类型转换运算符
A a2 = f(A(b)); // 正确，使用 A 的构造函数
// 不能使用强制类型转换解决二义性问题，因为强制类型转换本身也面临二义性问题
```



#### 二义性与转换目标为内置类型的多重类型转换

最好不要在类中定义两个以上转换源或转换目标是算术类型的转换

例子：两个构造函数参数是两种不同算术类型；同时含有两个类型转换运算符，转换目标也是两种不同的算术类型。

```cpp
// 定义的构造函数参数、类型转换运算符目标，都分别是 double，int
void f2(long double); // 一个函数
// 类型转换
A a;
f2(a); // 二义性错误

// 构造函数
long lg;
A a2(lg); // 二义性错误
// 因为无法确定最佳匹配（转换级别一致）
```



提示：

+ 不要令两个类执行相同的类型转换（即注意构造函数和类型转换运算符）
+ 避免转换目标是内置算术类型的类型转换，更要避免定义多个。



#### 重载函数与转换构造函数

重载函数的参数分属不同的类类型，且这些类定义了同样的转换构造函数，那么会出现二义性问题。只能显式调用构造函数进行使用，意味着程序设计存在不足。

且在调用过程，不会考虑可能出现的标准类型转换级别，会认为类型转换是一样好。



### 14.9.3 函数配匹与重载运算符

重载的运算符也是重载的函数，无法通过不同的调用形式来区分当前调用的是成员函数还是非成员函数。即表达式中运算符的候选函数集包含成员函数和非成员函数。

如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载运算符，则将会遇到重载运算符与内置运算符的二义性问题。（感觉还少说了算术类型到类的构造函数）



## 小结

略

