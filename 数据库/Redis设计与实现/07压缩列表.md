# 第 7 章 压缩列表

压缩列表是列表键和哈希键的底层实现之一。

当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度较短的字符串，那么 Redis 就会使用压缩列表列表来做列表键的底层实现。

当一个哈希键只包含少量键值对，并且每个键值对的键和值是小整数或短字符串，那么 Redis 会使用压缩列表来做哈希键的底层实现。



## 7.1 压缩列表的构成

压缩列表是 Redis 为了节约内存而开发的，是由一系列特殊编码的连续内存组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。



压缩列表的各个组成部分如下：

| 属性    | 类型     | 长度   | 用途                                               |
| ------- | -------- | ------ | -------------------------------------------------- |
| zlbytes | uint32_t | 4 字节 | 记录整个压缩列表占用内存字节数                     |
| zltail  | uint32_t | 4 字节 | 记录压缩列表表尾节点距离压缩列表起始节点有多少字节 |
| zllen   | uint16_t | 2 字节 | 记录压缩列表包含的节点数量                         |
| entryX  | 列表节点 | 不定   | 压缩列表包含的各个节点，长度由节点保存内容决定     |
| zlend   | uint8_t  | 1 字节 | 特殊值 0xFF（十进制 255），用于标记压缩列表的末尾  |



## 7.2 压缩列表节点的构成

每个压缩列表节点可以保存一个字节数组或一个整数值，其中，字节数组可以是以下三种长度的一种：

+ 长度小于等于（$2^6-1$）的字节数组
+ 长度小于等于（$2^{14}-1$）的字节数组
+ 长度小于等于（$2^{32}-1$）的字节数组



整数值可以是以下六种长度的一种：

+ 4 位长，0 至 12 之间的无符号整数
+ 1 字节长的有符号整数
+ 3 字节长的有符号整数
+ int16_t 类型整数
+ int32_t 类型整数
+ int64_t 类型整数



### 7.2.1 previous_entry_length

previous_entry_length 属性以字节为单位，记录了压缩列表中前一个节点的长度。

previous_entry_length 可以是 1 字节长，或 5 字节长。

+ 如果前一个节点的长度小于 254 字节， previous_entry_length 属性的长度为 1 字节。
+ 如果前一个节点的长度大于等于 254 字节，previous_entry_length 属性的长度为 5 字节，第一字节设为（0xFE 即 254），而后四字节则用于保存前一节点的长度。



遍历可以通过，zltail 得到尾部节点地址，然后倒序通过 previous_entry_length 遍历



### 7.2.2 encoding

encoding 记录节点的 content 属性保存的数据类型以及长度。

通过一定的编码规则，来区别数据类型以及长度。具体编码规则略。



### 7.2.3 content

content 属性保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的 encoding 属性决定。



## 7.3 连锁更新

插入、删除节点，可能发生连锁更新。连锁更新在最坏情况下需要执行 N 次空间重分配操作，而每次空间重分配的最坏复杂度为 $O(N)$ ，所以连锁更新的最坏复杂度为 $O(N^2)$

连锁更新复杂度较高，但是造成性能影响几率很低。需要满足恰好多个连续长度介于 250 至 253 节点之间的节点，连锁更新才有可能被引发。

即使出现连锁更新，只要被更新的节点数量不多，就不会对性能造成任何影响。



## 7.4 压缩列表 API

略



## 7.5 重点回顾

+ 压缩列表是一种为节约内存而开发的顺序性数据结构
+ 压缩列表被用作列表键和哈希键的底层实现之一
+ 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值
+ 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作

