# 第 2 章 简单动态字符串

Redis 自己构建了一种名为简单动态字符串（SDS）的抽象类型，C 字符串只会用作字符串字面量。

> redis > SET msg "hello world"
>
> OK

那么 Redis 将创建一个新的键值对，其中：键是一个字符串对象保存 `"msg"` 的 SDS，值也是一个字符串对象保存 `"hello world"` 的 SDS。

SDS 除了用来保存字符串还用作缓冲区：AOF 模块中的 AOF 缓冲区，以及客户端状态中的输入缓冲区。



## 2.1 SDS 的定义

`sds.h/sdshdr` 结构表示了一个 SDS，如下：

```c
struct sdshdr {
    // 记录 buf 数组中已使用字节的数量
    // 等于 SDS 所保存字符串的长度
    int len;
    // 记录 buf 数组中未使用字节的数量
    int free;
    // 字节数组，保存字符串
    char buf[];
};
```



保存字符串时，遵循以空字符结尾的惯例，但是末尾空字符不计算在 `len` 属性。

遵循以空字符结尾的好处是可以直接重用一部分 C 字符串函数库中的函数。且空字符对用户来说是透明的。



## 2.2 SDS 与 C 字符串的区别

### 2.2.1 常数复杂度获取字符串长度

SDS 获取字符串长度是 $O(1)$ ，而 C 字符串则是 $O(n)$



### 2.2.2 杜绝缓冲区溢出

`<string.h>/strcat` 函数可以将两个两个字符串进行拼接。但是如果两个字符串内存上紧邻，这时候拼接会产生缓冲区溢出。因为没有分配足够的空间。

SDS 的空间分配策略杜绝了缓冲区溢出的可能性：当 SDS API 需要对 SDS 进行修改时，API 会先检查 SDS 的空间是否满足修改所需的需求，如果不满足，则扩充 SDS 的空间。



### 2.2.3 减少修改字符串时带来的内存重分配次数

Redis 作为数据库，经常用于速度要求苛刻、数据频繁修改的场合。每次修改字符串都需要执行内存重分配的话，会对性能造成影响。

SDS 通过未使用空间 `free` 属性，实现『空间预分配』和『惰性空间释放』两种优化策略。



#### 空间预分配

需要对 SDS 空间进行扩展时，除了分配必要空间，还会分配额外的未使用空间。

其中额外的未使用空间数量由以下公式决定：

+ 修改后 SDS 的长度小于 1 MB，那么 free 属性与 len 属性相同。
+ 修改后 SDS 的长度大于等于 1 MB，那么只会分配固定的 1 MB未使用空间。

通过预分配策略，SDS 将连续增长 N 次字符串所需的内存重分配次数，从必定 N 次降低至最多 N 次。



#### 惰性空间释放

惰性空间释放用于优化 SDS 的字符串缩短操作。

当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是用 `free` 属性记录剩余空间，等待将来使用。

SDS 也提供相应的 API，让我们有需要时真正的释放 SDS 未使用的空间，不必担心内存浪费。



### 2.2.4 二进制安全

C 字符串中的字符必须符合某种编码（比如 ASCII），并且除了字符串末尾之外，字符串里面不能包含空字符。这些规则限制得 C 字符串只能保存文本数据，而不能保存二进制数据。

SDS 的 API 都是二进制安全的，所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据。

这也是将 SDS 的 buf 属性称为字节数组的原因。



### 2.2.5 兼容部分 C 字符串函数

虽然 SDS 的 API 都是二进制安全的，但一样遵循 C 字符串以空字符结尾的惯例，为的是让保存文本数据的 SDS 可以重用一部分 `<string.h>` 库定义的函数。避免了不必要的代码重复。



### 2.2.6 总结

| C 字符串                                     | SDS                                        |
| -------------------------------------------- | ------------------------------------------ |
| 获取字符串长度复杂度 $O(n)$                  | 获取字符串长度复杂度 $O(1)$                |
| API 不安全，可能会造成缓冲区溢出             | API 是安全的，不会造成缓冲区溢出           |
| 修改字符串长度 N 次必然需要执行 N 次内存分配 | 修改字符串长度 N 次最多执行 N 次内存重分配 |
| 只能保存文本数据                             | 可以保存文本或者二进制数据                 |
| 可以使用全部 `string.h` 库中函数             | 可以使用一部分 `string.h` 库中的函数       |



## 2.3 SDS API

| 函数        | 作用                                   | 时间复杂度                 |
| ----------- | :------------------------------------- | :------------------------- |
| sdsnew      | 创建一个包含给定 C 字符串的 SDS        | $O(N)$                   |
| sdsempty    | 创建一个空的 SDS                       | $O(1)$                   |
| sdsfree     | 释放给定的 SDS                         | $O(N)$                   |
| sdslen      | 返回 SDS 的已使用空间字节数            | $O(1)$                   |
| sdsavail    | 返回 SDS 的未使用空间字节数            | $O(1)$                   |
| sdsdup      | 创建一个给定 SDS 的副本                | $O(N)$              |
|sdsclear     |清空 SDS 保存的字符串内容      | 因为惰性释放策略，$O(1)$ |
| sdscat      | 将给定 C 字符串拼接到 SDS 字符串的末尾 | $O(N)$ ，N 为给 C 字符串的长度 |
| sdscatsds   | 将给定 SDS 字符串拼接到另一个 SDS 字符串末尾 | $O(N)$ ，N 为被拼接 SDS 字符串长度 |
| sdscpy      | 将给定的 C 字符串复制到 SDS，覆盖原有字符串 | $O(N)$ ，N 为被复制 C 字符串长度 |
| sdsgrowzero | 用空字符将 SDS 扩展至给定长度 | $O(N)$ ， N 为新增字节数 |
| sdsrange    | 保留 SDS 给定区间内的数据，不在区间内的数据会被覆盖或清除 | $O(N)$ ， N 为保留数据的字节数 |
| sdstrim     | 接受一个 SDS 和一个 C 字符串作为参数，从 SDS 中移出所有在 C 字符串中出现过的字符 | 书上说 $O(N^2)$ ，感觉是 $O(N*M)$ |
| sdscmp      | 对比两个 SDS 字符串是否相同 | $O(N)$ |



## 2.4 重点回顾

SDS 优点：

+ 常数获得字符串长度
+ 安全（不会缓冲区溢出）
+ 减少内存重分配次数
+ 二进制安全
+ 兼容部分 C 字符串函数

