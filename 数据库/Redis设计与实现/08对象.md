# 第 8 章 对象

Redis 基于前面这些数据结构创建了一个对象系统。

这个系统包含字符串对象、列表对象、哈希对象、集合对象、有序集合对象。

对象的好处，根据对象类型判断一个对象是否可以执行给定的命令；针对不同使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。

Redis 对象系统还实现基于引用计数的内存回收机制；还通过引用计数实现对象共享机制。

Reid 对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时间，空转时间长可能会优先被服务器删除。



## 8.1 对象的类型与编码

Redis 使用对象来表示数据库中的键和值，一个键值对至少包含两个对象。

Redis 每个对象由一个 `redisObject` 结构表示

```c
typedef struct redisObject {
    // 类型
    unsigned type:4;
    // 编码
    unsigned encoding:4;
    // 指向底层实现数据结构的指针
    void *ptr;
    // ...
} robj;
```



### 8.1.1 类型

type 属性记录对象的类型，属性值是下表中的常量

| 类型常量       | 对象的名称   |
| -------------- | ------------ |
| REDIS_STRING | 字符串对象   |
| REDIS_LIST   | 列表对象     |
| REDIS_HASH   | 哈希对象     |
| REDIS_SET    | 集合对象     |
| REDIS_ZSET   | 有序集合对象 |

对数据库键执行 TYPE 命令，命令返回的是数据库键对应的值对象的类型，而不是键对象的类型。



### 8.1.2 编码和底层实现

对象 ptr 指针指向对象的底层实现数据结构，这些数据结构由对象的 encoding 属性决定。

encoding 属性记录对象所使用的编码，即对象使用了什么数据结构作为底层实现。

对象的编码如下表所示：

| 编码常量                    | 编码所对应的底层数据结构      |
| --------------------------- | ----------------------------- |
| REDIS_ENCODING_INT        | long 类型的整数             |
| REDIS_ENCODING_EMBSTR     | embstr 编码的简单动态字符串 |
| REDIS_ENCODING_RAW        | 简单动态字符串                |
| REDIS_ENCODING_HT         | 字典                          |
| REDIS_ENCODING_LINKEDLIST | 双端链表                      |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                      |
| REDIS_ENCODING_INTSET     | 整数集合                      |
| REDIS_ENCODING_SKIPLIST   | 跳跃表和字典                  |

每种类型的对象都至少使用了两种不同的编码，具体见下表：

| 类型           | 编码                        | 对象                                                 |
| -------------- | --------------------------- | ---------------------------------------------------- |
| REDIS_STRING | REDIS_ENCODING_INT        | 使用整数值实现的字符串对象。                         |
| REDIS_STRING | REDIS_ENCODING_EMBSTR     | 使用 embstr 编码的简单动态字符串实现的字符串对象。 |
| REDIS_STRING | REDIS_ENCODING_RAW        | 使用简单动态字符串实现的字符串对象。                 |
| REDIS_LIST   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的列表对象。                         |
| REDIS_LIST   | REDIS_ENCODING_LINKEDLIST | 使用双端链表实现的列表对象。                         |
| REDIS_HASH   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的哈希对象。                         |
| REDIS_HASH   | REDIS_ENCODING_HT         | 使用字典实现的哈希对象。                             |
| REDIS_SET    | REDIS_ENCODING_INTSET     | 使用整数集合实现的集合对象。                         |
| REDIS_SET    | REDIS_ENCODING_HT         | 使用字典实现的集合对象。                             |
| REDIS_ZSET   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的有序集合对象。                     |
| REDIS_ZSET   | REDIS_ENCODING_SKIPLIST   | 使用跳跃表和字典实现的有序集合对象。                 |



`OBJECT ENCODING` 命令可以查看一个数据库键的值对象的编码。

不是为特定类型的对象关联一种固定的编码，极大的提升了 Redis 的灵活性和效率。



## 8.2 字符串对象

字符串对象的编码可以是 `int` 、`raw` 、`embstr` 。



如果字符串对象保存的是一个字符串值，大于 32 字节使用 `raw` 编码，小于等于 32 字节使用 `embstr` 编码方式。

`embstr` 编码方式只调用一次内存分配申请一块连续的空间，创建 `redisObject` 和 `sdshdr` 结构。而 `raw` 编码会调用两次内存分配。



long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的。在有需要时，程序会将字符串值转换回浮点数值，执行某些操作。



### 8.2.1 编码的转换

如通过 `APPEND` 命令，向保存整数值的字符串对象追加一个字符串值，那么字符串编码方式会从 `int` 变为 `raw` 。

`embstr` 编码的字符串对象没有任何相应的修改程序，所以对 `embstr` 编码方式执行修改命令时，程序会将对象的编码变为 `raw` ，再执行命令。



### 8.2.2 字符串命令的实现

介绍一些字符串命令在不同编码方式下的实现，略。



## 8.3 列表对象

列表对象的编码可以是 `ziplist` 或者 `linkedlist`

`ziplist` 编码的列表对象使用压缩列表作为底层实现，`linkedlist` 编码的列表对象使用双端链表作为底层的实现。

注意字符串对象是 Redis 五种类型的对象中唯一会被其他四种类型对象嵌套的对象。



### 8.3.1 编码转换

当列表对象同时满足以下两个条件时，列表对象使用 `ziplist` 编码，不满足时会转换为 `linkedlist` ：

+ 列表对象保存的所有字符串元素的长度都小于 64 字节
+ 列表对象保存的元素数量小于 512 个



以上两个条件的上限值可以修改，具体见配置文件 `list-max-ziplist-value` 选项和 `list-max-ziplist-entries` 。



### 8.3.2 列表命令的实现

略



## 8.4 哈希对象

哈希对象的编码可以是 `ziplist` 或者 `hashtable`

`ziplist` 编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，会先将保存键的节点推入表尾，再将保存值的节点推入表尾。

`hashtable` 编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存。每个键和值都是一个字符串对象。



### 8.4.1 编码转换

当哈希对象同时满足以下两个条件时，使用 `ziplist` 编码，否则使用（转换） `hashtable` 编码：

+ 哈希对象保存的所以键值对的键和值的字符串长度小于 64 字节
+ 哈希对象保存的键值对数量小于 512 个



以上两个条件的上限值可以修改，具体见配置文件 `hash-max-ziplist-value` 选项和 `hash-max-ziplist-entries` 。



### 8.4.2 哈希命令的实现

略



## 8.5 集合对象

集合对象的编码可以是 `intset` 或者 `hashtable` 。

`intset` 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里。

`hashtable` 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为 NULL。



### 8.5.1 编码的转换

当集合对象同时满足以下两个条件时，使用 `intset` 编码，否则使用（转换） `hashtable` 编码：

+ 集合对象所有元素都是整数值
+ 集合对象保存的元素数量不超过 512 个

第二个条件的上限值可以修改，具体见配置文件 `set-max-intset-entries` 选项



### 8.5.2 集合命令的实现

略



## 8.6 有序集合对象

有序集合的编码可以是 `ziplist` 或者 `skiplist` 。

`ziplist` 编码使用压缩列表作为底层实现，每个元素使用两个节点保存，一个节点保存元素成员，一个节点保存元素的分值。压缩列表内部的集合元素按分值从小到大排序。

`skiplist` 编码的有序集合对象使用 `zset` 结构作为底层实现，一个 `zset` 结构同时包含一个字典和一个跳跃表。

跳跃表实现范围查询，字典可以快速查询指定成员。跳跃表和字典通过指针共享成员和分值。



### 8.6.1 编码的转换

当有序集合对象同时满足以下两个条件时，使用 `ziplist` 编码，否则使用（转换） `skiplist` 编码：

+ 有序集合保存的元素数量小于 128 个
+ 有序集合保存的所有元素成员的长度都小于 64 字节



以上两个条件的上限值可以修改，具体见配置文件 `zset-max-ziplist-entries` 选项和 `zset-max-ziplist-value` 。



### 8.6.2 有序集合命令的实现

略



## 8.7 类型检查与命令多态

Redis 用于操作键的命令基本上分为两种

+ 一种命令可以对任何类型的键使用，DEL 、EXPIRE、RENAME、TYPE、OBJECT 等
+ 只能对特定类型的键执行的命令，SET、GET、APPEND 等



### 8.7.1 类型检查的实现

类型特定命令所进行的类型检查是通过 `redisObject` 结构的 `type` 属性来实现的：

+ 在执行一个类型特定命令前，服务器会先检查输入数据库键的值对象是否为执行命令所需类型
  + 是则执行命令
  + 否则返回类型错误



### 8.7.2 多态命令的实现

Redis 会根据值对象的编码方式，选择正确的代码来执行命令。



## 8.8 内存回收

Redis 在自己的对象系统中构建了一个引用计数实现内存回收机制，



## 8.9 对象共享

对象的引用计数还带有对象共享的作用。

Redis 会在初始化服务器时，创建一些常用整数值字符串对象，当服务器需要用到值相同的对象时，服务器会共享这些对象，而不是创建新对象。



## 8.10 对象的空转时长

`redisObject` 还包含一个 `lru` 属性，该属性记录对象最后一次被命令程序访问的时间。

可以根据这个属性得到空转时长。

如果服务器打开 `maxmemory` 选项，且服务器用于回收内存的算法是 `volatile-lru` 或 `allkeys-lru` ，那么当内存超过上限值时，会先释放空转时长较高的键，回收内存。



## 8.11 重点回顾

+ Redis 数据库的每个键值对的键和值都是一个对象
+ Redis 共有字符串、列表、哈希、集合、有序集合五类对象，每种对象至少有两种编码方式
+ 服务器执行命令前，会检查键的类型（即键的值对象类型）是否能执行指定的命令
+ Redis 使用引用计数实现内存回收
+ Redis 会共享值 0 ~ 9999 的字符串对象
+ 对象会记录最后一次访问时间，可用于得到空转时间

